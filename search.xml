<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue源码分析——从render()到生成vnode]]></title>
    <url>%2F2020%2F05%2F13%2Fvue-code-3-render%2F</url>
    <content type="text"><![CDATA[前言本篇是vue源码分析的第三篇，上一篇讲到开始执行 _update() ，本片从_update()开始，延伸到render()，再到生成 vnode 、具体分析在 patch 之前Vue都做了些什么。 VNodevirtual dom 是一个用原生js对象去描述的 DOM 节点，它比创建一个 DOM 的代价要小很多。在vue中，virtual dom 是用 vnode 这么一个 class 去描述，它定义在 src/core/vdom/vnode.js 中。123456789101112// src/core/vdom/vnode.js// 可以看到整个 vnode 的定义就是一个classexport default class VNode &#123; tag: string | void; // 什么类型的标签 data: VNodeData | void; // 数据 VNodeData定义在flow/vnode.js中 children: ?Array&lt;VNode&gt;; // VNode实际上是一个树，每个VNode拥有自己的children text: string | void; // 文本 elm: Node | void; // 对于dom对象的持有 ... ...&#125; vnode 其实是一个tree，每个 vnode 拥有自己的 children , children 又拥有自己的 children ，最终构成 vnode-tree。 Vue 的 vnode 参考了 snabbdom 的实现，并在 snabbdom 的基础上做了许多扩展，有兴趣的可以去了解一下。 vnode 是本篇中非常重要的一个概念，请带着这个概念继续往下阅读。 手写render示例 官方是这样定义render的。&nbsp; 手写 render() 长这样。123456789101112131415new Vue(&#123; el: '#app', render(createElement) &#123; return createElement ('div', &#123; attrs: &#123; id: '#newApp' //此处是newApp，非app，后面会用到 &#125; &#125;, this.message) // 此处相当于子节点 &#125;, data() &#123; return &#123; message: 'hello' &#125; &#125;&#125;) ❗️即使使用了 template，最后也会通过一系列操作转化为 render 函数，这一点可以从Vue官网的生命周期图里直观的体现出来（没错，就是你已经看吐了的那张）。 Compile template into render function如果指定了 template 选项，那么我们就会将 template 编译到 render 函数中。 在看render()的实现之前，我们先来看一下 initRender(), 也就是初始化render，这个函数在 initMixin() 中执行，有关 initMixin() 的部分可以去 initMixin() 中查看。 initRender()initRender() 的核心部分就是 vm._c、vm.$createElement 这两个函数，它们都调用了 createElement 方法，区别在最后一个参数不同。12345678910111213141516// src/core/instance/render.js// 这个函数在init过程中执行。export function initRender (vm: Component) &#123; vm._vnode = null // the root of the child tree vm._staticTrees = null // v-once cached trees const options = vm.$options const parentVnode = vm.$vnode = options._parentVnode // the placeholder node in parent tree const renderContext = parentVnode &amp;&amp; parentVnode.context vm.$slots = resolveSlots(options._renderChildren, renderContext) vm.$scopedSlots = emptyObject // _c是被编译生成的render函数所使用的方法，这是一个私有方法。 vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) // vm.$createElement 是为手写render函数提供的创建vnode方法，例如 vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true)&#125; createElement() 给手写render函数提供了一个创建 vnode 的方法，例如上文的示例。 createElement() 会在执行 _render() 的时候被调用，上一篇文章 中我们提到过，vm._update 传入了2个参数，第一个参数是通过 vm._render() 生成的一个 vnode，第二个参数 hydrating 是服务端渲染相关。 12345// lifecycle.jsupdateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating)&#125; 我们从 vm._update() 追溯到 mountComponent()，再到 vm.$mount(vm.$options.el), 发现并没有传入第二个参数（这块最好可以打开源码自己看一下），所以我们重点分析 _render() 方法, 它返回一个VNode。 render()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// instance/render.js......Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options ... ... let vnode try &#123; currentRenderingInstance = vm vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; handleError(e, vm, `render`) // return error render result, // or previous vnode to prevent render error causing blank component /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production' &amp;&amp; vm.$options.renderError) &#123; try &#123; // render方法实际上就会生产一个vnode vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) &#125; catch (e) &#123; handleError(e, vm, `renderError`) vnode = vm._vnode &#125; &#125; else &#123; vnode = vm._vnode &#125; &#125; finally &#123; currentRenderingInstance = null &#125; // if the returned array contains only a single node, allow it if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123; vnode = vnode[0] &#125; // return empty vnode in case the render function errored out // 判断我们的vnode是否是VNode的实例 if (!(vnode instanceof VNode)) &#123; // 如果不是，那么说明我们模板有了多个根节点，多个根节点会返回多个vnode，所以抛出警告 if (process.env.NODE_ENV !== 'production' &amp;&amp; Array.isArray(vnode)) &#123; warn( 'Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm ) &#125; vnode = createEmptyVNode() &#125; // set parent vnode.parent = _parentVnode // 最后把这个vnode返回出去（Vue.prototype._render） return vnode&#125; render 函数 调用 call 方法，把this指向了 vm._renderProxy, 并且把 vm.$createElement 作为参数传入。 vm._renderProxy 的定义也发生在 initMixin() 的时候。 vm._renderProxy1234567// instance/init.jsif (process.env.NODE_ENV !== 'production') &#123; initProxy(vm)&#125; else &#123; vm._renderProxy = vm&#125; 如果说当前在生产环境，就直接把 vm._renderProxy 赋值给 vm， 也就是 this，如果是开发环境就执行 initProxy()。 initProxy()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 // instance/proxy.js ... ... // hasProxy 判断当前游览器是否支持Proxy const hasProxy = typeof Proxy !== 'undefined' &amp;&amp; isNative(Proxy) // 警告 在render过程中使用了一个没有在属性、方法或data中定义的值 */ const warnNonPresent = (target, key) =&gt; &#123; warn( `Property or method "$&#123;key&#125;" is not defined on the instance but ` + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target ) &#125; // 警告 key必须通过$data.key的形式访问，在Vue实例中，为了防止与Vue内部的 内置属性 或 API 发生冲突， 所以 以 “$” 或 “_” 开头的属性不被代理到Vue中（给出的链接中提到，访问这类属性需要用vm.$data._property）。 const warnReservedPrefix = (target, key) =&gt; &#123; warn( `Property "$&#123;key&#125;" must be accessed with "$data.$&#123;key&#125;" because ` + 'properties starting with "$" or "_" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals. ' + 'See: https://vuejs.org/v2/api/#data', target ) &#125; const hasHandler = &#123; has (target, key) &#123; // 元素是否在target上，如果元素不再target上，has为false const has = key in target // isAllowed是全局的一些属性方法，或者是一些私有方法 const isAllowed = allowedGlobals(key) || (typeof key === 'string' &amp;&amp; key.charAt(0) === '_' &amp;&amp; !(key in target.$data)) // key不在target中，并且判断isAllowed为false if (!has &amp;&amp; !isAllowed) &#123; // 如果key存在于target.$data中，就会报一个 warnReservedPrefix 警告。 if (key in target.$data) warnReservedPrefix(target, key) // 否则会报 warnNonPresent 警告。 else warnNonPresent(target, key) &#125; return has || !isAllowed &#125; &#125; initProxy = function initProxy (vm) &#123; // 首先判断hasProxy if (hasProxy) &#123; const options = vm.$options // options上存在render属性并且render属性上存在_withStripped属性。 const handlers = options.render &amp;&amp; options.render._withStripped ? getHandler : hasHandler // 此处的 vm._renderProxy 指向 hasHandler vm._renderProxy = new Proxy(vm, handlers) &#125; else &#123; // 否则直接指向vm vm._renderProxy = vm &#125; &#125;&#125;export &#123; initProxy &#125; 执行到这，我们拿到了一个代理过后的Vue，这个代理的作用就是当我们访问某一个属性和或方法的时候，去判断这个方法是否存在于vm上。 接下来我们来看一下第二个参数， vm.$createElement都做了些什么。 createElement()无论是 vm._c 还是 vm.$createElement，最后都是会返回 createElement 方法，这个方法的定义在 create-element.js 中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// src/core/vdom/create-element.js......export function createElement ( context: Component, // vm实例 tag: any, // vnode的tag标签 data: any, // vnode相关数据 children: any, // 子vnode normalizationType: any, alwaysNormalize: boolean): VNode | Array&lt;VNode&gt; &#123; // 当没有data的时候 就会把后面的参数往前移，这就是对参数不一致的一种处理 if (Array.isArray(data) || isPrimitive(data)) &#123; normalizationType = children children = data data = undefined &#125; // 如果 alwaysNormalize 为true，则 normalizationType 为 ALWAYS_NORMALIZE if (isTrue(al waysNormalize)) &#123; normalizationType = ALWAYS_NORMALIZE &#125; /* createElement实际上最后是调用了_createElement 此处的createElement只是为_createElement做了一层参数封装 都处理好了后到_createElement里去真正的处理VNode */ return _createElement(context, tag, data, children, normalizationType)&#125;// 这才是真正的createElement函数，用它来创建VNode节点。export function _createElement ( context: Component, tag?: string | Class&lt;Component&gt; | Function | Object, data?: VNodeData, children?: any, normalizationType?: number): VNode | Array&lt;VNode&gt; &#123; /* 判断data是否已定义，并且判断data是否是响应式的 */ if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\n` + 'Always create fresh vnode data objects in each render!', context ) return createEmptyVNode() &#125; 当把一个对象调用 defineReactive 的时候，就会给对象添加一个 __ob__ 属性，一旦有 __ob__ 这个属性，就说明传入的 data 参数是响应式的，_createElement 判断data如果是响应式的，就会报出一个警告，然后调用 createEmptyVNode创建空节点。 createEmptyVNode 的实现↓。123456789// src/core/vdom/vnode.js// 创建一个vnode实例，不传参数，实际上这就是一个注释节点，注释vnodeexport const createEmptyVNode = (text: string = '') =&gt; &#123; const node = new VNode() node.text = text node.isComment = true return node&#125; 继续来看 _createElement 的实现。1234567891011121314151617181920212223242526272829303132333435363738394041// src/core/vdom/create-element.js ... ... return createEmptyVNode() &#125; // 判断是否有is属性，如果有就把tag指向is（例如 component 的 is 属性） if (isDef(data) &amp;&amp; isDef(data.is)) &#123; tag = data.is &#125; // 判断如果component:is为false，就会返回注释节点。 if (!tag) &#123; return createEmptyVNode() &#125; // 对key做一些校验，如果key不是基础类型就会报错 if (process.env.NODE_ENV !== 'production' &amp;&amp; isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key) ) &#123; if (!__WEEX__ || !('@binding' in data.key)) &#123; warn( 'Avoid using non-primitive value as key, ' + 'use string/number value instead.', context ) &#125; &#125; // slot处理 if (Array.isArray(children) &amp;&amp; typeof children[0] === 'function' ) &#123; data = data || &#123;&#125; data.scopedSlots = &#123; default: children[0] &#125; children.length = 0 &#125; // 对所有的children做normalize if (normalizationType === ALWAYS_NORMALIZE) &#123; children = normalizeChildren(children) &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; children = simpleNormalizeChildren(children) &#125; 在继续往下看之前，我们先来看一下 normalize 都做了些什么 normalizeChildren() &amp; simpleNormalizeChildren() _createElement 的参数 children 一般都是一个类数组（拥有length），所以我们通过对 normalize 对 children 做了一层遍历，如果发现每个元素都是数组的话，就调用 Array.prototype.concat.apply([], children) 把数组扁平化（只做一层）， 出现这种情况是因为可能会有一些 function component。 简单来说，simpleNormalizeChildren 的使用场景就是认为 children 中也有数组，而我们最终期望的是扁平一维数组，每个数组中都是一个 vnode。 ❗️如果原始的 children 中，某个 children 又是一个数组，相当于二维数组，这个方法不用考虑递归情况。也就是说 children 中的每一项是否还是数组，不在这个函数的考虑范围。 12345678910111213141516171819// src/core/vdom/helpers/normalize-children.jsexport function simpleNormalizeChildren (children: any) &#123; for (let i = 0; i &lt; children.length; i++) &#123; if (Array.isArray(children[i])) &#123; return Array.prototype.concat.apply([], children) &#125; &#125; return children&#125;/* 普通的normalizeChildren 最终返回也是一维数组，每个数组也是vnode */export function normalizeChildren (children: any): ?Array&lt;VNode&gt; &#123; return isPrimitive(children) // 判断是否是基础类型 ? [createTextVNode(children)] // 如果是 直接返回一个长度为一、也就是只有一个值([createTextVNode(children)])的一维数组（文本节点）。 : Array.isArray(children) // 如果不是基础类型就判断是否是array类型 ? normalizeArrayChildren(children) : undefined&#125; createTextVNode()123456// src/core/vdom/vnode.js// 实例化vnode，前三个参数（tag, data, children）为undefined，第四个参数(text)为string，所以是文本vnodeexport function createTextVNode (val: string | number) &#123; return new VNode(undefined, undefined, undefined, String(val))&#125; normalizeArrayChildren()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// src/core/vdom/helpers/normalize-children.jsfunction normalizeArrayChildren (children: any, nestedIndex?: string): Array&lt;VNode&gt; &#123;//首先定义了一个要返回的数组res，然后遍历children const res = [] let i, c, lastIndex, last for (i = 0; i &lt; children.length; i++) &#123; c = children[i] if (isUndef(c) || typeof c === 'boolean') continue lastIndex = res.length - 1 last = res[lastIndex] // nested if (Array.isArray(c)) &#123; // 如果发现children本身就是一个array（与上面normalizeChildren或simpleNormalizeChildren不同，可能会有多层嵌套，比如slot/v-for生成的vnode.children就有可能是这样） if (c.length &gt; 0) &#123; // 这种情况就会递归的调用normalizeArrayChildren，把结果放到c上 c = normalizeArrayChildren(c, `$&#123;nestedIndex || ''&#125;_$&#123;i&#125;`) // merge adjacent text nodes // 优化部分，考虑最后处理的节点与下次处理的第一个节点如果都是一个文本节点就合并处理 if (isTextNode(c[0]) &amp;&amp; isTextNode(last)) &#123; res[lastIndex] = createTextVNode(last.text + (c[0]: any).text) c.shift() &#125; res.push.apply(res, c) &#125; &#125; else if (isPrimitive(c)) &#123; // 否则判断是一个基础类型 if (isTextNode(last)) &#123; // 如果是文本节点就createTextVNode res[lastIndex] = createTextVNode(last.text + c) &#125; else if (c !== '') &#123; // push createTextVNode // convert primitive to vnode res.push(createTextVNode(c)) &#125; &#125; else &#123; // 正常VNode情况，对v-for之类做处理，最终也是push到res上 if (isTextNode(c) &amp;&amp; isTextNode(last)) &#123; // merge adjacent text nodes res[lastIndex] = createTextVNode(last.text + c.text) &#125; else &#123; // default key for nested array children (likely generated by v-for) if (isTrue(children._isVList) &amp;&amp; isDef(c.tag) &amp;&amp; isUndef(c.key) &amp;&amp; isDef(nestedIndex)) &#123; c.key = `__vlist$&#123;nestedIndex&#125;_$&#123;i&#125;__` &#125; res.push(c) &#125; &#125; &#125; // 最后返回出去 return res&#125; normalizeArrayChildren 比起上面两个参数，多考虑了递归情况。其次，在处理过程中，如果遇到了最后处理的节点和新处理的节点同样都是文本节点的话，就会合并优化，目的就是变成一维VNode。 到目前为止就是 _createElement 做的第一件事情——对所有 children 做 normalize 的处理，变成一维数组，而第二个事情就是创建 VNode, 我们继续回到 _createElement。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// src/core/vdom/create-element.js ... children = simpleNormalizeChildren(children) &#125; let vnode, ns // 对tag做一些判断，tag可以是string，也可以是一个组件 if (typeof tag === 'string') &#123; let Ctor ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) // config.isReservedTag(tag) 用来判断这些标签是不是html的原生标签 if (config.isReservedTag(tag)) &#123; // platform built-in elements // 如果修饰符用在原生html标签上，并且是开发环境，就会抛出一个警告，说修饰符只在组件上有效 if (process.env.NODE_ENV !== 'production' &amp;&amp; isDef(data) &amp;&amp; isDef(data.nativeOn)) &#123; warn( `The .native modifier for v-on is only valid on components but it was used on &lt;$&#123;tag&#125;&gt;.`, context ) &#125; // 创建平台的保留标签，把data/children等都创建进去，然后去实例化一个vnode，例如&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;就是保留标签。 vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) &#125; else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, 'components', tag))) &#123; // component vnode = createComponent(Ctor, data, context, children, tag) &#125; else &#123; // 陌生节点直接创建一个vnode vnode = new VNode( tag, data, children, undefined, undefined, context ) &#125; &#125; else &#123; /* 如果是 new Vue(&#123; el: '#app', render(h) &#123; return h(App) &#125; &#125;) 这种形式的话，实际上传入的就不是一个字符串（例如div），而是一个组件对象（object类型），就会执行createComponent。 */ vnode = createComponent(tag, data, context, children) &#125; if (Array.isArray(vnode)) &#123; // 把vnode作为createElement的返回值返回出去 return vnode &#125; else if (isDef(vnode)) &#123; if (isDef(ns)) applyNS(vnode, ns) if (isDef(data)) registerDeepBindings(data) return vnode &#125; else &#123; return createEmptyVNode() &#125;&#125; 由此可知，createElement 最后返回一个 vnode， 再把 vnode 返回给之前调用 Vue.prototype._render 方法，然后再回到 123updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating)&#125; 这里的第一个参数就是刚刚 createElement 的返回值，_update 把 vnode 生成为真实的 dom。 除了在首次渲染的时候会调用 _update，在数据改变的时候同样会调用，来看一下 _update 的定义。 _update()12345678910111213141516// src/core/instance/lifecycle.jsVue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; // 首先定义一些变量，以便在数据更新时使用。 const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode if (!prevVnode) &#123; // 首次渲染调用 vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // 更新 vm.$el = vm.__patch__(prevVnode, vnode) &#125; 无论是首次调用，还是数据更新，都会把 vm.__patch__() 赋值给 vm.$el， vm.__patch__() 是 Virtual DOM Diff的核心，它用来插入真实的 DOM。 12345678// src/platforms/web/runtime/index.js// 判断是否在浏览器环境（因为vuejs可以跑在服务端，而服务端不会有DOM，所以如果非浏览器端就等于一个空函数）Vue.prototype.__patch__ = inBrowser ? patch : noop// src/platforms/web/runtime/index.jsexport function noop (a?: any, b?: any, c?: any) &#123;&#125; 我们肯定运行在浏览器环境，所以继续往下查找 patch 的定义。 1234// src/platforms/web/runtime/patch.js// 调用patch 其实就等同于调用 createPatchFunctionexport const patch: Function = createPatchFunction(&#123; nodeOps, modules &#125;) nodeOps 中都是一些操作DOM的方法，可以去 src/platforms/web/runtime/node-ops.js 中查看。 而 modules 其实就是在 web/runtime/modules/index 下定义了很多 class 、attrs 的钩子函数。在 path 过程中，会调用不同模块的钩子函数，modules 的定义在 src/platforms/web/runtime/patch.js中。 123456// src/platforms/web/runtime/patch.js...import platformModules from 'web/runtime/modules/index'const modules = platformModules.concat(baseModules) 看完两个参数，继续来看下 createPatchFunction。 1234567891011121314151617181920212223242526272829303132333435363738// src/core/vdom/patch.js......const hooks = ['create', 'activate', 'update', 'remove', 'destroy']......export function createPatchFunction (backend) &#123; // 遍历所有模块，然后拿到一部分钩子，然后把hooks都保存到cbs这个对象里面 在patch阶段会执行各个阶段的钩子，在patch过程中，去到相对应的钩子就会执行相关模块的钩子函数 let i, j const cbs = &#123;&#125; const &#123; modules, nodeOps &#125; = backend for (i = 0; i &lt; hooks.length; ++i) &#123; cbs[hooks[i]] = [] for (j = 0; j &lt; modules.length; ++j) &#123; if (isDef(modules[j][hooks[i]])) &#123; cbs[hooks[i]].push(modules[j][hooks[i]]) &#125; &#125; &#125; // 定义了许多辅助方法 ... ... // 最后return了一个patch return function patch (oldVnode, vnode, hydrating, removeOnly) &#123; ... ... &#125;&#125; 绕了这么一大圈，我们最后知道，调用 createPatchFunction 等同于调用最后的 patch 方法，那么向上翻阅，一开始 _update 中的 vm.__patch__ 执行的也就是 createPatchFunction 中的 patch，vm.__patch__ 中的参数最后也会传入进这个 patch，我们来回顾一下，这些参数都传了些什么。 1234567891011121314// src/core/instance/lifecycle.jsVue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; ... ... if (!prevVnode) &#123; // vm.$el: dom对象, vnode: 渲染生成的vnode——watcherDom, hydrating: 上文提到过是false vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; 回到 patch() 方法 patch()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112return function patch (oldVnode, vnode, hydrating, removeOnly) &#123; // 如果vnode未定义，则直接调用销毁钩子 if (isUndef(vnode)) &#123; if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return &#125; let isInitialPatch = false const insertedVnodeQueue = [] if (isUndef(oldVnode)) &#123; // 如果oldVnode未定义，则创建一个新的根节点 isInitialPatch = true createElm(vnode, insertedVnodeQueue) &#125; else &#123; // 判断是否是真实dom（是否拥有nodeType） const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; // patch existing root node // 如果是同一个节点直接修改相同节点 patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) &#125; else &#123; if (isRealElement) &#123; // 如果oldVnode是服务器渲染的，修改hydrating记为true if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123; oldVnode.removeAttribute(SSR_ATTR) hydrating = true &#125; // 如果hydrating为true if (isTrue(hydrating)) &#123; // 合并到真实DOM if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123; invokeInsertHook(vnode, insertedVnodeQueue, true) return oldVnode &#125; else if (process.env.NODE_ENV !== 'production') &#123; warn( 'The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing ' + 'full client-side render.' ) &#125; &#125; // 把真实dom转化为vnode oldVnode = emptyNodeAt(oldVnode) &#125; // replacing existing element // 真实dom 例如div#app const oldElm = oldVnode.elm // 拿div#app距离 parentElm就是body const parentElm = nodeOps.parentNode(oldElm) // create new node // createElm的作用是把vnode挂载到真实的dom上 createElm( vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a // leaving transition. Only happens when combining transition + // keep-alive + HOCs. (#4590) oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ) // update parent placeholder node element, recursively // 组件相关逻辑 if (isDef(vnode.parent)) &#123; let ancestor = vnode.parent const patchable = isPatchable(vnode) // 如果组件根节点被替换，那么会遍历更新 while (ancestor) &#123; for (let i = 0; i &lt; cbs.destroy.length; ++i) &#123; cbs.destroy[i](ancestor) &#125; ancestor.elm = vnode.elm if (patchable) &#123; for (let i = 0; i &lt; cbs.create.length; ++i) &#123; cbs.create[i](emptyNode, ancestor) &#125; // #6513 // invoke insert hooks that may have been merged by create hooks. // e.g. for directives that uses the "inserted" hook. const insert = ancestor.data.hook.insert if (insert.merged) &#123; // start at index 1 to avoid re-invoking component mounted hook for (let i = 1; i &lt; insert.fns.length; i++) &#123; insert.fns[i]() &#125; &#125; &#125; else &#123; registerRef(ancestor) &#125; ancestor = ancestor.parent &#125; &#125; // destroy old node if (isDef(parentElm)) &#123; // 删除老节点 removeVnodes([oldVnode], 0, 0) &#125; else if (isDef(oldVnode.tag)) &#123; // 调用destroy钩子 invokeDestroyHook(oldVnode) &#125; &#125; &#125; // 调用insert钩子 invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch) return vnode.elm&#125; createElm()createElm() 的作用是把 vnode 创建成真正的 DOM，并把它挂载到它的父节点中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// vue-src/core/vdom/patch.js function createElm ( vnode, insertedVnodeQueue, // 空数组 parentElm, // 父节点 refElm, // oldElm的下一个节点 nested, ownerArray, index ) &#123; if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123; // 这里的vnode是一个组件vndoe vnode = ownerArray[index] = cloneVNode(vnode) &#125; vnode.isRootInsert = !nested if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123; return &#125; const data = vnode.data const children = vnode.children const tag = vnode.tag if (isDef(tag)) &#123; if (process.env.NODE_ENV !== 'production') &#123; if (data &amp;&amp; data.pre) &#123; creatingElmInVPre++ &#125; // 检测是否注册了组件 if (isUnknownElement(vnode, creatingElmInVPre)) &#123; warn( 'Unknown custom element: &lt;' + tag + '&gt; - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context ) &#125; &#125; // 首先定义了一个element（当前元素） vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode) // 对原生创建dom的一个封装 setScope(vnode) if (__WEEX__) &#123; ... ... &#125; else &#123; // web平台逻辑 // 如果vnode还有子节点那么先创建子节点 createChildren(vnode, children, insertedVnodeQueue) if (isDef(data)) &#123; invokeCreateHooks(vnode, insertedVnodeQueue) &#125; // 插入DOM insert(parentElm, vnode.elm, refElm) &#125; if (process.env.NODE_ENV !== 'production' &amp;&amp; data &amp;&amp; data.pre) &#123; creatingElmInVPre-- &#125; &#125; else if (isTrue(vnode.isComment)) &#123; // 没有tag会走到这里，判断是否是注释节点 vnode.elm = nodeOps.createComment(vnode.text) insert(parentElm, vnode.elm, refElm) &#125; else &#123; // 创建文本节点 vnode.elm = nodeOps.createTextNode(vnode.text) insert(parentElm, vnode.elm, refElm) &#125;&#125; 再来看一下 insert() 与 createChildren()这两个方法。 insert() &amp; createChildren()123456789101112131415161718192021222324252627282930function insert (parent, elm, ref) &#123; if (isDef(parent)) &#123; // 判断是否有ref，此处是之前oldElm的下一个兄弟节点 if (isDef(ref)) &#123; // 判断ref 的 parentNode 是否与传入的parent相等 if (nodeOps.parentNode(ref) === parent) &#123; // 使用insertBefore插入 nodeOps.insertBefore(parent, elm, ref) &#125; &#125; else &#123; // 否则插入父节点 nodeOps.appendChild(parent, elm) &#125; &#125;&#125;function createChildren (vnode, children, insertedVnodeQueue) &#123; // 如果传入的是一个数组，遍历调用createElm去创建children，同时把当前的vnode当作父节点插入 if (Array.isArray(children)) &#123; if (process.env.NODE_ENV !== 'production') &#123; checkDuplicateKeys(children) &#125; for (let i = 0; i &lt; children.length; ++i) &#123; createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i) &#125; &#125; else if (isPrimitive(vnode.text)) &#123; // 如果传入的是一个普通对象，就直接调用appendChild方法去添加 nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text))) &#125;&#125; 如果 VNode 拥有 children，那么就会调用 createChildren() 去创建 children，它是一个递归调用 createElm() 的过程（递归调用子节点的 createElm()，然后一层层地去插入子节点），最终调用 insert 去插入。 如果没有 children就直接使用 insert() 来插入 DOM 。 由此看出，我们是先插入子元素，再插入父元素，父元素最终会挂载到一个真实的 DOM 上，不知道你是否还记得 patch 中有这么几行代码，让我们回到 patch。 123456// src/core/vdom/patch.js if (isDef(parentElm)) &#123; removeVnodes([oldVnode], 0, 0) &#125; else if (isDef(oldVnode.tag)) &#123; invokeDestroyHook(oldVnode) &#125; 前面提到过，这是删除节点的操作。 打个比方，比如说我们最早拥有一个 &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; 标签，当我们经历了一系列操作，最后会生成一个带有 message 的新 DOM 节点，然后把之前的节点删除掉。 再来回忆一下最初的示例。 123456789101112131415new Vue(&#123; el: '#app', render(createElement) &#123; return createElement ('div', &#123; attrs: &#123; id: '#newApp' //此处是newApp，非app，后面会用到 &#125; &#125;, this.message) // 此处相当于子节点 &#125;, data() &#123; return &#123; message: 'hello' &#125; &#125;&#125;) 手写 render 与直接写在 HTML 中的区别是，如果以 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 的形式直接写在 HTML里，即使不执行 new Vue，也会渲染这个标签，如果执行了 new Vue，那么会在这之后执行 $mount 去把 message 替换成真实的数据。 而使用 render 方法并没有变化插值的过程，当 render 函数执行完毕的时候，就会把 message 给替换上去。 我们最终挂载的元素会替换掉原有的元素，也就是说，我们即使定义了 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; ,也会被 #newApp 替换掉，页面渲染完成后只会留下 &lt;div id=&quot;newApp&quot;&gt;&lt;/div&gt;，这也就是为什么不能在 body 或 html 上挂载元素的原因，因为我们不可以替换 body 或 html 。 总结在 initRender() 过程中，定义了 vm._c 和 vm.$createElement 方法，vm._c 是为被编译生成的 render 所提供的的方法，而 vm.$createElement 是为手写 render 所提供的方法，它们都调用了 createElement 函数，而 createElement 函数会在执行 _render() 时被调用。 当我们调用 _update() 时，就会执行 _render()，_render() 返回一个 VNode，这个 VNode 就是靠 createElement 函数生成的。 createElement 函数做了两件事，第一件是为了兼容 function component，所以会对 children 做 扁平化（normalizeChildren() || simpleNormalizeChildren() || normalizeArrayChildren）处理，另一件就是生成 VNode。 当我们调用 _render() 取到 VNode 后，会调用 patch() 来创建新节点。 patch() 会通过 createElm 把 VNode 创建成真实的DOM，插入新节点，最后再去删除老节点。 如果 VNode 拥有 children，那么就会调用 createChildren()，利用 createChildren() 去递归调用 createElm() 创建 children，再一层层地去插入子节点，插入顺序是由子到父。]]></content>
      <tags>
        <tag>notes</tag>
        <tag>vue</tag>
        <tag>source-code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue源码分析——从new Vue()到到实例挂载]]></title>
    <url>%2F2020%2F04%2F28%2Fvue-code-2-mount%2F</url>
    <content type="text"><![CDATA[本篇文章介绍了从new Vue()初始化到挂载Vue实例的过程，其中覆盖了new Vue()、initState()、$mount等等，接下来我们就来揭开 new Vue() 的神秘面纱。 new Vue()看到 new Vue()，我们首先想到，new 操作符代表着实例化一个对象，而这里的Vue，实际上就是一个类，想知道 new Vue() 时发生了什么，我们首先要找到Vue的定义，因为 runtime-compiler 版本比 runtime-only 版本多了一步模板编译，所以本篇选择分析 runtime-compiler 版本，入口文件为entry-runtime-with-compiler。 入口123456789101112// entry-runtime-with-compiler.js......import Vue from './runtime/index'......// 这个文件最终导出了一个Vue对象，这个Vue引入自'./runtime/index'export default Vue 当我们打开./runtime/index的时候会发现，这里的Vue是引入自core/index的，我们继续向上查找，最终在src/core/instance/index.js里找到了Vue的定义。123456789101112131415161718192021222324252627// src/core/instance/index.jsimport &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; // 警告 vue必须要通过new的方法去实例化它 warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options) // 这个_init是在initMixin中定义的, 用来初始化Vue&#125;// 通过这些Mixin往Vue类上挂载了许多原型方法，本篇重点看一下initMixin()initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 到这里，我们可以把Vue理解为是用函数实现的一个类，类上通过Mixin方法给Vue的原型挂载了很多原型方法。除了Mixin，在runtime/index.js里或者entry-runtime-with-compiler中 也定义了很多原型方法。 除此之外，在刚刚的core/index文件中，Vue还会通过initGlobalAPI(Vue)给Vue挂载了许多静态属性与方法，在学习initMixin(Vue)之前，我们先来看一下initGlobalAPI(Vue)都做了些什么。 initGlobalAPI()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// global-api/index.jsimport config from '../config'import &#123; initUse &#125; from './use'import &#123; initMixin &#125; from './mixin'import &#123; initExtend &#125; from './extend'import &#123; initAssetRegisters &#125; from './assets'import &#123; set, del &#125; from '../observer/index'import &#123; ASSET_TYPES &#125; from 'shared/constants'import builtInComponents from '../components/index'import &#123; observe &#125; from 'core/observer/index'import &#123; warn, extend, nextTick, mergeOptions, defineReactive&#125; from '../util/index'export function initGlobalAPI (Vue: GlobalAPI) &#123; // config const configDef = &#123;&#125; configDef.get = () =&gt; config // configDef来源 if (process.env.NODE_ENV !== 'production') &#123; configDef.set = () =&gt; &#123; // 警告不要替换Vue.config对象，请设置单独的字段。 warn( 'Do not replace the Vue.config object, set individual fields instead.' ) &#125; &#125; // 往vue的config上定义了configDef Object.defineProperty(Vue, 'config', configDef) // Vue源码中的注释 ↓↓ // exposed util methods. // NOTE: these are not considered part of the public API - avoid relying on // them unless you are aware of the risk. // 翻译过来就是定义了一些暴露出去的util方法，但是这些方法并不属于公共API，所以vue官方并不建议去使用这些util方法，因为内部实现不稳定，有风险（可能会改变实现方法）。 Vue.util = &#123; warn, extend, mergeOptions, defineReactive &#125; // 往vue上添加了set/delete/nextTick方法 Vue.set = set Vue.delete = del Vue.nextTick = nextTick // observable API 这个observable是2.6新增的API，有兴趣可以看一下文档 Vue.observable = &lt;T&gt;(obj: T): T =&gt; &#123; observe(obj) return obj &#125; &lt;/T&gt; // options 可以用来合并一些方法 Vue.options = Object.create(null) // export const ASSET_TYPES = ['component', 'directive', 'filter']; // ASSET_TYPES的定义在shared/constants.js中，这一步就是把component，directive，filter挂载到options上面 ASSET_TYPES.forEach(type =&gt; &#123; Vue.options[type + 's'] = Object.create(null) &#125;) // _base被用来标识基本构造函数（也就是Vue），以便在多场景下添加组件扩展 Vue.options._base = Vue // builtInComponents是一个内置组件，详见components/index，这个文件导出了KeepAlive，由此可以看出KeepAlive其实是Vue的一个内置组件，它通过extend方法扩展到Vue.options.components下面。 extend(Vue.options.components, builtInComponents) // 初始化Vue.use()方法 initUse(Vue) // 初始化全局mixin方法 initMixin(Vue) // 初始化vue的extend方法 initExtend(Vue) // 把component、directive、filter定义到全局 initAssetRegisters(Vue)&#125; 在初始化过程中，vue完成了全局方法的定义，只有把这些方法定义了以后，才能在代码中使用这些方法。 vue的初始化过程： 找到Vue的定义。 然后在Vue下面通过Mixin方法给原型挂载了很多原型方法。 又通过initGlobalApi()给vue挂载了很多静态方法。 最后就可以在代码中使用了。 initMixin()在构建Vue实例的时候，使用了this._init(options),这里面的_init方法是在initMixin中定义的，这也是initMixin做的唯一的一件事，在构造Vue实例的时候会调用_init方法来初始化Vue，来看一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// src/core/instance/init.jsexport function initMixin (Vue: Class&lt;Component&gt;) &#123; Vue.prototype._init = function (options?: Object) &#123; const vm: Component = this vm._uid = uid++ let startTag, endTag if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; startTag = `vue-perf-start:$&#123;vm._uid&#125;` endTag = `vue-perf-end:$&#123;vm._uid&#125;` mark(startTag) &#125; vm._isVue = true if (options &amp;&amp; options._isComponent) &#123; initInternalComponent(vm, options) &#125; else &#123; /* 这里把我们传入的options最后都合并到$options上 例如，vm.$options.el 其实就是 new Vue(&#123; el: 这里的el data: vm.$options.data &#125;) */ vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) &#125; if (process.env.NODE_ENV !== 'production') &#123; initProxy(vm) // _renderProxy 这个之后在render部分会分析 &#125; else &#123; vm._renderProxy = vm &#125; vm._self = vm /* 初始化生命周期，为当前实例添加一些生命周期标识与属性。 例如$parent、$children、$refs、_isMounted、_isDestroyed等。 */ initLifecycle(vm) // 初始化事件 initEvents(vm) // 初始化render，这个也会在之后的render部分分析 initRender(vm) // 调用beforeCreate钩子函数 callHook(vm, 'beforeCreate') // 初始化inject initInjections(vm) // resolve injections before data/props // 初始化props、methods、data、computed与watch initState(vm) // 初始化provide initProvide(vm) // 调用created钩子函数 callHook(vm, 'created') if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; // 格式化组件名 vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue $&#123;vm._name&#125; init`, startTag, endTag) &#125; // 初始化结束 判断有没有el if (vm.$options.el) &#123; /* 在$mount之后转化为DOM对象 这个函数执行完，dom会立刻发生变化 通俗点说，就是挂载组件 */ vm.$mount(vm.$options.el) &#125; &#125;&#125; 从上文中，我们可以直观的看出Vue初始化的一个过程，也了解到，为什么我们在created阶段不能访问DOM，因为DOM的挂载是在vm.$mount时才执行的，我们先来看一下initState()，其他几个会在之后的篇章分析，本章不做具体介绍。 initState()1234567891011121314151617181920212223// state.jsexport function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options // 判断options，如果定义了props，就会初始化props if (opts.props) initProps(vm, opts.props) // 判断methods，如果定义了methods，就会初始化methods if (opts.methods) initMethods(vm, opts.methods) // 判断data，如果定义了data，就会初始化data if (opts.data) &#123; initData(vm) &#125; else &#123; // 没有data的时候绑定一个空对象 observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; // 初始化computed if (opts.computed) initComputed(vm, opts.computed) // 初始化watcher if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 我们在初始化data的时候调用了initData方法, 来看一下initData()都做了些什么。 initData()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function initData (vm: Component) &#123; let data = vm.$options.data // 判断是不是function，并赋值给了vm._data data = vm._data = typeof data === 'function' ? getData(data, vm) // 获取data数据 : data || &#123;&#125; // 判断data是否非对象，如果非对象就返回警告 if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; // 遍历data对象 const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length // 遍历data中的keys while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; // 保证不与props与methods里的key重复，如果有重复则爆出警告，这个警告我们应该都很熟悉 if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method "$&#123;key&#125;" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property "$&#123;key&#125;" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; // 判断是否是非保留字段 // 能在vue里可以使用this互相调用data或者methods等等，就是通过这个代理 proxy(vm, `_data`, key) &#125; &#125; // observe data observe(data, true /* asRootData */)&#125; 在initData()中，我们使用一个循环判断了是否使用了重复的键名，假如data里使用了msg这个字段, 那么props里或methods里等等就不可以再用了。不能使用重复的键名是因为无论是data、props、还是methods等，最终都会挂载到vm实例上，一个实例上拥有重复的key显然是不正确的。 当一系列的判断通过后，我们会调用proxy()来重新代理vm，使我们可以用更简单的方式去访问属性，下面来看一下。 proxy() 123456789101112131415161718192021222324 // state.js const sharedPropertyDefinition = &#123; enumerable: true, configurable: true, get: noop, set: noop &#125;// 参数对应initData()中的proxy(vm, `_data`, key)export function proxy (target: Object, sourceKey: string, key: string) &#123; // 定义get、set方法。 sharedPropertyDefinition.get = function proxyGetter () &#123; return this[sourceKey][key] // this._data.key &#125; sharedPropertyDefinition.set = function proxySetter (val) &#123; this[sourceKey][key] = val &#125; /* 通过Object.defineProperty对target.key的访问增加了get和set target其实就是传入的vm, 所以vm.key.get就会执行proxyGetter() */ Object.defineProperty(target, key, sharedPropertyDefinition)&#125; 当我们去访问vm.data的时候，实际上就会去访问this[sourceKey][key], 等同于vm._data.key。 所以说，proxy实际上就是将数据代理到我们的vm上，让我们可以通过this._data.key访问，也可以通过this.key这种方式访问。 ❗️不建议使用_data这种方式，因为在js的世界中，带_的变量默认都是私有的。 最后来看一下$mount。 $mount1234567891011121314// src/platforms/web/entry-runtime-with-compiler.js// 用mount常量保存下来vue原型的$mount方法，在下面会调用const mount = Vue.prototype.$mount// 重新定义$mount方法，因为这一块的逻辑是给 runtime-compiler 版本使用的，也就是带模板编译的版本，而runtime-only版本没有下面这块逻辑。Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el)...... el最终会得到query(el)的返回值，所以先来看一下query()都做了些什么 query()12345678910111213141516171819// platforms/web/util/index.jsexport function query (el: string | Element): Element &#123; // 如果参数是字符串就调用querySelector寻找这个元素 if (typeof el === 'string') &#123; const selected = document.querySelector(el) // 如果找不到就报错，返回空div if (!selected) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'Cannot find element: ' + el ) return document.createElement('div') &#125; return selected &#125; else &#123; // 如果参数是一个DOM对象就直接返回 return el &#125;&#125; 由此可知，query() 就是返回一个DOM的实例对象，我们回到Vue.prototype.$mount，继续阅读接下来的代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// entry-runtime-with-compiler.jsel = el &amp;&amp; query(el);/* 拿到el后，此时的el已经是一个DOM对象，然后再次做一次判断。 判断el是否是body或者是文档标签（html） 如果是就会报一个错, 意思是说“你的vue不可以直接挂载到body或html上” 因为我们挂载节点时会覆盖节点，而我们如果覆盖了body或html肯定是不正确的。 这也是我们为什么通常使用div#app这种方式去做Vue的根节点，而不是直接挂载到body或html上的原因。 */if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this&#125;// 获取$optionsconst options = this.$options/* 这里会判断有没有手写render方法，例如 ↓↓ new Vue(&#123; el: '#app', render(h) &#123; return h(App) &#125; &#125;) */// 在render不存在的时候才会编译template，否则优先调用renderif (!options.render) &#123; let template = options.template // 紧接着判断new vue中有没有template if (template) &#123; // 当template是字符串时 if (typeof template === 'string') &#123; // 判断字符串是否以id(#)为元素选择器 if (template.charAt(0) === '#') &#123; // idToTemplate方法内部通过query()获取转化后的元素，如果转化成功则返回元素内的innerHTML template = idToTemplate(template) // 如果没有通过id选择器获取到对应的元素，则会报一个警告 if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) &#123; warn( `Template element not found or is empty: $&#123;options.template&#125;`, this ) &#125; &#125; &#125; else if (template.nodeType) &#123; /* template也可以是一个dom对象，例如 ↓↓ new Vue(&#123; el: '#app', template: document.querySelector('#app'), &#125;) 如果template是dom对象就会去取innerHTML */ template = template.innerHTML &#125; else &#123; // 既不字符串也不是dom的话会抛出警告 if (process.env.NODE_ENV !== 'production') &#123; warn('invalid template option:' + template, this) &#125; return this &#125; &#125; else if (el) &#123; // 没有template情况，就调用getOuterHTML，这个方法最终返回一个字符串 template = getOuterHTML(el) &#125; 来看一下getOuterHTML方法，这个方法其实和它的名字一样，就是拿到DOM对象的outerHTML。 getOuterHTML()12345678910111213141516// entry-runtime-with-compiler.js/** * Get outerHTML of elements, taking care * of SVG elements in IE as well. */function getOuterHTML (el: Element): string &#123; if (el.outerHTML) &#123; return el.outerHTML &#125; else &#123; // 从源码上的注释上来看，IE中的SVG无素就获取不到outerHTML，所以，如果没有outerHTML的话就在外面包一层再执行innerHTML, 这样等同于拿到了outerHTML。 const container = document.createElement('div') container.appendChild(el.cloneNode(true)) return container.innerHTML &#125;&#125; 刚刚无论使用了什么方法，我们都已经获取到了template，接下来我们来看一下模板（template）编译部分。1234567891011121314151617181920212223242526272829 // entry-runtime-with-compiler.js if (template) &#123; /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; mark('compile') &#125; // 通过compileToFunctions生成render函数以及staticRenderFns(静态render函数)，staticRenderFns不需要在VNode更新时再进行patch，此处属于性能优化。 const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; outputSourceRange: process.env.NODE_ENV !== 'production', shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this) // 分别赋值给options.render 与 options.staticRenderFns options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; mark('compile end') measure(`vue $&#123;this._name&#125; compile`, 'compile', 'compile end') &#125; &#125; &#125; // 如果有render函数就可以直接调用mount方法，如果没有就会把模板转化，编译生成render()，然后调用 ↓↓ return mount.call(this, el, hydrating) // 这个mount就是一开始缓存的Vue.prototype.$mount&#125; 在看mount.call(this, el, hydrating)的代码之前，我们先来总结一下。 在执行$mount的时候，首先会对el做一个解析，判断el是否是body或html，如果判断通过，会再判断是否存在render方法，如果不存在就转化为一个template，这个template最终会被编译成render。 可以看出，无论用什么方法，Vue最终只认render函数，并且，如果有render函数会直接调用mount方法，如果没有就通过模板编译生成render函数，有了render函数之后再去调用mount。 或许你会对 runtime-compiler 版本重新定义 $mount 方法有所疑问，那是因为 runtime-compiler 在挂载组件之前，需要执行一遍把组件对象中可能定义的 template 编译生成 render 函数的过程。而 runtime-only 版本只支持在组件对象中定义 render 函数。 也就是说 runtime-compiler 版本的 $mount 会多做一步编译模板，而runtime-only不需要考虑模板编译的事情。除了模板编译，它们之后的流程都一样的，所以可以复用后面的 mount 逻辑。 好了，我们来看一下上面提到的可复用的逻辑部分——被缓存起了来$mount都做了些什么。 1234567891011121314// runtime/index.jsVue.prototype.$mount = function ( el?: string | Element, // 可以是字符串也可以是DOM hydrating?: boolean): Component &#123; /* 因为在runtime-only版本会直接走到这里，所以还是需要对el做一层判断 后面的inBrowser判断是否是浏览器环境 */ el = el &amp;&amp; inBrowser ? query(el) : undefined // 挂载组件，注意此处的el已经是通过query(el)转化后的dom return mountComponent(this, el, hydrating)&#125; mountComponent123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// lifecycle.jsexport function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean ): Component &#123; // 把el用vm.$el做缓存 vm.$el = el // 判断render函数（并没有写render函数并且template没有正确转化render函数的情况） if (!vm.$options.render) &#123; // 那么就会使用createEmptyVNode创建一个空vnode vm.$options.render = createEmptyVNode /* 抛出警告。 这个错误其实就是使用了runtime-only版本，然后又写了template而不是写render函数。 或者说写了template但是没有使用runtime-compiler版本。 */ if (process.env.NODE_ENV !== 'production') &#123; /* istanbul ignore if */ if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== '#') || vm.$options.el || el) &#123; warn( 'You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm ) &#125; else &#123; // 还有一种情况是没有写template也没有写render函数 warn( 'Failed to mount component: template or render function not defined.', vm ) &#125; &#125; &#125; // 触发beforeMount钩子 callHook(vm, 'beforeMount') // 定义updateComponent，最终将作为Watcher对象的getter函数，用来收集依赖 let updateComponent // 在开发环境并且配置了performance和mark，性能埋点相关 if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; const name = vm._name const id = vm._uid const startTag = `vue-perf-start:$&#123;id&#125;` const endTag = `vue-perf-end:$&#123;id&#125;` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue $&#123;name&#125; render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) mark(endTag) measure(`vue $&#123;name&#125; patch`, startTag, endTag) &#125; &#125; else &#123; updateComponent = () =&gt; &#123; // 定义vm._update，_update的第一个参数是通过vm._render生成的一个vnode，第二个参数hydrating是服务端渲染相关，这两个函数就是最终挂载dom需要用的函数。 vm._update(vm._render(), hydrating) &#125; &#125; // 调用了一个new Watcher执行updateComponent new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) &#123; // 代表组件已挂载的标志位 vm._isMounted = true // 触发mounted钩子 callHook(vm, 'mounted') &#125; return vm&#125; 通过 Watcher 使用 updateComponent 是因为 updateComponent 方法实际上就是执行了一次真实的渲染。而真实的渲染过程除了首次渲染，之后在更新数据的时候还是会触发渲染 Watcher，再次执行 updateComponent 方法，而当数据发生变化视图修改时，入口也是 updateComponent 方法，看一下 Watcher 的定义。 Watcher1234567891011121314151617181920212223242526272829303132333435363738394041// watcher.jsexport default class Watcher &#123; ... ... constructor ( vm: Component, // vue实例 expOrFn: string | Function, // expression or function 表达式或函数 cb: Function, // callback回调 options?: ?Object, // 配置对象 isRenderWatcher?: boolean // 是否是渲染watcher的boolean值, 刚刚我们传了true, 所以这是一个渲染watcher。 ) &#123; this.vm = vm if (isRenderWatcher) &#123; // 如果是渲染watcher的话在vm上加一个_watcher vm._watcher = this &#125; vm._watchers.push(this) ... ... // 判断expOrFn如果是函数，如果是就把getter赋值给这个函数，此处对应刚刚传入的updateComponent方法。 if (typeof expOrFn === 'function') &#123; this.getter = expOrFn &#125; else &#123; // 调用parsePath转化一下expOrFn this.getter = parsePath(expOrFn) ... ... get () &#123; pushTarget(this) let value const vm = this.vm try &#123; // 在这里调用getter，也就是执行传入updateComponent的方法 value = this.getter.call(vm, vm) &#125; 回到lifecycle.js，执行 updateComponent。 12345678// lifecycle.js updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) /* 开始执行 vm._update(vm._render(), hydrating) vm._update、vm._render()这两个函数就是最终挂载dom需要用的函数 先执行render, render生成一个vnode，然后调update，把vnode传入进去 */ &#125; Watcher 的 getter 为 updateComponent 函数，用于触发所有渲染所需要用到的数据的 getter，进行依赖收集，该 Watcher 实例会存在所有渲染所需数据的闭包Dep中。 总结一下 $mount 的实现，如果在 runtime-compiler 版本的话，会先对el做一些处理，如果没有定义 render 函数的话，就会去尝试获取 render 函数（把template通过一系列的逻辑判断，尝试把template转化为render函数，因为template支持很多写法，例如直接写template，或者template是一个dom，不写的话也可以通过el去获取template，最后把template通过编译的手段去转化为render函数）。也就是说，$mount 在 runtime-compiler 版本中，首先要拿到 render 函数，然后调用 mountComponent 方法。 mountComponent 中，定义了 updateComponent 方法，这个函数是一个渲染watcher，之所以通过watcher，是因为updateComponent 方法实际上就是执行了一次渲染，这个渲染过程除了首次，之后在更新数据时，还是会触发这个渲染watcher，再次执行 updateComponent 方法。这是一个监听→执行的过程，当监听数据发生变化、视图修改，入口也是 updateComponent 方法，这就是渲染watcher做的事情。 其实很多分析在代码中和总结中都说了一遍，虽然有点唠叨，但是主要目的也是为了加深记忆。能看到这里都比较辛苦，所以希望这篇文章可以多少对你有点帮助。我也是第一次读Vue源码，如果有对哪里有疑问或者有问题的地方，还希望可以指出来，大家多多交流。 碎碎念创建这篇文章的时候是4月28日，今天是5月28日，一晃又拖了一个月，肯定不是我拖，嗯，是这篇文章太长了。 北京最近的天气好的不像话，上周末的时候天气就好得惊人，那天本来想去北海公园转转，结果当天因为疫情期间去公园的话需要提前预约导致没去成，还郁闷了好久，不过现在来看来这周末还是可以去的，我真是被上天宠爱的人啊，哈哈哈 ~ 有时候人快乐起来真的很简单，有一个好天气就够了。]]></content>
      <tags>
        <tag>notes</tag>
        <tag>vue</tag>
        <tag>source-code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue源码分析——目录与构建流程]]></title>
    <url>%2F2020%2F04%2F05%2Fvue-source-code-1-build%2F</url>
    <content type="text"><![CDATA[前言终于开始记录vue源码啦 ~ 本篇是Vue源码系列的第一篇，而且这篇文章竟然拖了整整20天（笑），因为原本打算把render、createElm等等都写在一篇文章里，后来想想果然写博客也该遵循下组件化思想，还是分开维护的好😂，不废话了，先来看看源码目录。 vue源码目录1234567891011121314151617181920212223├─benchmarks # 性能测试相关demo├─dist # 项目构建后不同版本的vue文件├─examples # 用vue写的一些小demo├─flow # flow类型声明文件、定义全局方法、变量类型├─packages # 一些npm包，可以通过npm install单独使用。├─scripts # 项目构建相关的脚本和配置文件├─src # vue核心源码│ ├─complier # 模板编译相关代码│ ├─core # vue核心中的核心代码│ │ ├─components # 内置组件的代码(keep-alive)│ │ ├─global-api # 全局api(如extend、mixin)│ │ ├─instance # 实例化相关（渲染、初始化、生命周期等）│ │ ├─observe # 响应式相关代码│ │ ├─util # 一些工具方法│ │ └─vdom # virtual dom相关代码（create-element、create-element等）│ ├─platforms # 跨平台兼容（例如weex)│ │ ├─web # 浏览器平台（日常开发)│ │ └─weex # 类似rn的跨端应用│ ├─server # 服务器SSR渲染相关代码│ ├─sfc # 解释器，可以把单文件(*.vue)编译成一个js对象│ └─shared # 辅助方法，可以被core或cpmpiler等等与platforms目录共享的一些辅助方法会放到这个目录下├─test # 项目测试用例└─types # 新版本vue支持typescript，此处为typescript相关声明文件 package.json我们先从构建的入口看起，打开vue的package.json。 123456789101112131415161718192021// package.jsonconst vue = &#123; "name": "vue", //npm包名字 "version": "2.6.11", // 版本 "description": "Reactive, component-oriented view layer for modern web interfaces.", // 包的描述 "main": "dist/vue.runtime.common.js", // 入口，我们在import vue的时候会通过main去查找入口 "module": "dist/vue.runtime.esm.js", // 类似main，在webpack2以上会把module做默认入口 ... ... // scripts定义了许多脚本，每个脚本都是一个任务 通过npm run ** 就可以执行不同的任务 "scripts": &#123; "dev": "rollup -w -c scripts/config.js --environment TARGET:web-full-dev", ... &#125; &quot;dev&quot;: &quot;rollup -w -c scripts/config.js --environment TARGET:web-full-dev&quot; 在介绍这条命令之前，我们先来了解一下rollup是何方神圣。 Rollup与Webpack我相信大家在平时技术选型的时候，大概率都会选择webpack作为构建工具，因为我们深知webpack的强大，可为什么vue却选择rollup作为构建工具呢，难道webpack不香吗？ webpack可以把各种各样的静态资源（图片、css等）都编译成js，而rollup只处理js部分，不处理其他资源。 webpack实现了代码分割，它将我们的项目分割成了多个易于管理的模块，这意味着我们可以实现按需加载，再也不必等待整个应用被下载并解析完成才可以使用，这无疑会让我们的用户有更愉快的交互体验，而rollup并不能做到代码分割。 roll的设计理念是想打造一个尽可能高效地构建、精简易分发的js库。在处理代码时，rollup会把代码放在同一个地方，并且会在一起进行处理，因此，我们最终将得到更加精简的代码、以及更快的运行速度。 相比之下，虽然rollup没有webpack那么强大，但rollup却更加轻量，编译后的代码也更加友好，更适合处理js库，这也正是Vue选择rollup的原因，除此之外，Vuex、Vue-router同样使用了rollup，甚至React在2017年也将webpack更换成了rollup。 回到刚刚的dev命令。 &quot;dev&quot;: &quot;rollup -w -c scripts/config.js --environment TARGET:web-full-dev&quot; -w（watch）表示监听文件，他代表在文件发生改变时重新构建。 c表示使用config配置文件来打包，如果没有默认配置文件，就会使用rollup.config.js去打包，不过我们已经后面已经指定了使用scripts/config.js来配置打包，所以我们在执行dev命令时，会使用scripts/config.js去配置rollup —environment设置环境变量，后面的TARGET表示环境变量名，web-full-dev表示环境参数。 当然，本篇重点介绍构建流程，而Vue的构建，就是通过script里与build相关的任务。123456789101112131415"scripts": &#123; "dev": "rollup -w -c scripts/config.js --environment TARGET:web-full-dev", ... // 构建相关的任务 // build web平台的一些js "build": "node scripts/build.js", // build 输出serve-render相关 "build:ssr": "npm run build -- web-runtime-cjs,web-server-renderer", // build 输出weex相关 "build:weex": "npm run build -- weex", &#125;,&#125; 在我们执行构建的时候，实际上也就是通过nodejs去执行一些脚本，拿”build”来说，就是执行了scripts/build.js。 构建流程先来看一下大体的构建流程，进入scripts/build.js文件。 1234567891011121314151617181920212223242526272829303132// build.js// 定义依赖模块const fs = require('fs')const path = require('path')const zlib = require('zlib')const rollup = require('rollup')const terser = require('terser')// 判断是否有dist文件，如果不存在就创建。if (!fs.existsSync('dist')) &#123; fs.mkdirSync('dist')&#125;// 从config.js里拿到要构建的所有的配置let builds = require('./config').getAllBuilds()// 然后对配置做一层过滤 if (process.argv[2]) &#123; const filters = process.argv[2].split(',') builds = builds.filter(b =&gt; &#123; return filters.some(f =&gt; b.output.file.indexOf(f) &gt; -1 || b._name.indexOf(f) &gt; -1) &#125;)&#125; else &#123; // filter out weex builds by default builds = builds.filter(b =&gt; &#123; return b.output.file.indexOf('weex') === -1 &#125;)&#125;// 最终调用build函数做真正的构建过程build(builds) fs 模块是Node.js提供的一组用于与文件系统进行交互（以类似于标准 POSIX 函数的方式）的 API。 参考：fs.existsSync(path)fs.mkdirSync(path[, options]) 获取配置let builds = require(&#39;./config&#39;).getAllBuilds()然后我们来看一下config.js，看一下究竟是如何拿到的配置。 12345678910111213// config.js...if (process.env.TARGET) &#123; // 这边对应刚刚package.json里的"dev"任务传来的环境变量，如果是执行npm run dev，直接执行到这里。 module.exports = genConfig(process.env.TARGET)&#125; else &#123; // 我们执行build的时候没有传TARGET这个环境变量，所以执行到这里去取构建所需的配置。 exports.getBuild = genConfig // 通过Object.keys(builds)拿到一个key的数组，然后通过map方法调用genConfig函数 exports.getAllBuilds = () =&gt; Object.keys(builds).map(genConfig)&#125; exports.getAllBuilds = () =&gt; Object.keys(builds).map(genConfig)来看一下Object.keys(builds) 中的 builds builds对象123456789101112131415161718// config.js// 每个key都是一个对象，builds其实就是不同版本vuejs的编译配置集合。const builds = &#123; 'web-runtime-cjs-dev': &#123; /* * entry(入口) * 通过resolve传一个字符串，这里面的web是作为函数中base。 */ entry: resolve('web/entry-runtime.js'), // dest（目标） dest: resolve('dist/vue.runtime.common.dev.js'), format: 'cjs', env: 'development', banner &#125;,&#125; 可以看到，entry与dest中都使用了resolve，下面来看一下resolve函数究竟都做了些什么？ resolve()123456789101112131415// config.jsconst aliases = require('./alias')const resolve = p =&gt; &#123; // 首先接受一个参数p，然后通过split拿到第一个值，拿resolve('web/entry-runtime.js')举例来说，最终得到的base就是web const base = p.split('/')[0] // 紧接着，去alias.js寻找base对应的alias if (aliases[base]) &#123; return path.resolve(aliases[base], p.slice(base.length + 1)) &#125; else &#123; return path.resolve(__dirname, '../', p) &#125;&#125; 1234567891011121314151617181920212223// alias.jsconst path = require('path')/* * nodejs提供的一个路径解析方法，__dirname为当前目录，此处为alias.js所在的目录。 * '../' 代表往上去寻找一级，此处找到了vue大目录 * 通过传参（p)找到最终文件 */ const resolve = p =&gt; path.resolve(__dirname, '../', p)// 最终导出一个对象module.exports = &#123; vue: resolve('src/platforms/web/entry-runtime-with-compiler'), compiler: resolve('src/compiler'), core: resolve('src/core'), shared: resolve('src/shared'), web: resolve('src/platforms/web'), weex: resolve('src/platforms/weex'), server: resolve('src/server'), sfc: resolve('src/sfc')&#125;// alias其实就是提供了一个到最终真实文件地址的一个映射关系，通过key的方式获取。 12345678910111213141516171819// config.jsconst aliases = require('./alias')const resolve = p =&gt; &#123; const base = p.split('/')[0] // 刚刚我们通过 resolve('web/entry-runtime.js') 获取到值为'web'的base，所以说，通过aliases[base]找到的就是web: resolve('src/platforms/web')这个地址。这个地址存在，所以进入if条件。 if (aliases[base]) &#123; return path.resolve(aliases[base], p.slice(base.length + 1)) // p.slice(base.length + 1) 实际上就是resolve('web/entry-runtime.js')中的'entry-runtime.js'。 &#125; else &#123; return path.resolve(__dirname, '../', p) &#125;&#125; 12345678910111213// config.jsconst builds = &#123; 'web-runtime-cjs-dev': &#123; entry: resolve('web/entry-runtime.js'), // dest同样使用了resolve函数，所以base值为dist, 但是alias里没有配置dist, 所以会走resolve函数的else逻辑。 dest: resolve('dist/vue.runtime.common.dev.js'), // format是构建出的文件格式（dist目录下的文件，例如vue.runtime.common.dev.js ）。 format: 'cjs', env: 'development', banner &#125;,&#125; 来看一下打包出的文件结尾。 123456// vue.runtime.common.dev.js......module.exports = Vue; 123456// vue.runtime.esm......export default Vue; 12345678// vue.runtime.js ... ... return Vue;&#125;)); format表示构建的格式，通过不同的格式构建出不同的版本（导出不同格式的js），”cjs”表示遵循Commonjs规范、”umd”表示遵循UMD规范，”es”表示遵循ES Module规范。 最后来看下banner。 12345678910// config.js// banner定义注释 库的版本 谁创建的 等等const banner = '/*!\n' + ` * Vue.js v$&#123;version&#125;\n` + ` * (c) 2014-$&#123;new Date().getFullYear()&#125; Evan You\n` + ' * Released under the MIT License.\n' + ' */' 随便看一个打包好的文件。12345678910// vue.esm.js// 此处就是banner生成的 ↓↓/*! * Vue.js v2.6.11 * (c) 2014-2019 Evan You * Released under the MIT License. *//* */ exports.getAllBuilds = () =&gt; Object.keys(builds).map(genConfig)刚刚看完了builds，我们现在来看一下genConfig都做了些什么。 genConfig()1234567891011121314151617181920212223242526272829303132333435// config.js...// 通过object.keys(builds)拿到所有key的一个数组，然后调用genconfig函数，之后genConfig就拿到了每个keyfunction genConfig (name) &#123; // opts是通过builds[name]拿到一个对象。 const opts = builds[name] // 然后通过opts构造出一个新的config对象，因为这个config对象的数据结构才是rollup所对应的配置结构，例如entry只是我们自己定义的，但是rollup里叫input，所以需要转换。 const config = &#123; input: opts.entry, external: opts.external, plugins: [ flow(), alias(Object.assign(&#123;&#125;, aliases, opts.alias)) ].concat(opts.plugins || []), output: &#123; file: opts.dest, format: opts.format, banner: opts.banner, name: opts.moduleName || 'Vue' &#125;, onwarn: (msg, warn) =&gt; &#123; if (!/Circular/.test(msg)) &#123; warn(msg) &#125; &#125; &#125; ... ... return config&#125; 其实genConfig就是把builds的配置通过一层映射和转化生成终rollup所需要的配置（数组），返回到build.js的下面。 写入文件build()、buildEntry()、write()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// build.js// 也就是说build最终得到一个数组。let builds = require('./config').getAllBuilds()// 因为我们会编译生成不同的vuejs，所以我们会根据我们传的参数不同，得到最终需要编译的buildsif (process.argv[2]) &#123; // 这里对应的就是--weex --web这些参数 // 如果有这些参数，它就会根据传的参数通过filters把不需要的打包的给过滤掉，如果没有参数的话就把weex给过滤掉（也就是打包web平台） const filters = process.argv[2].split(',') builds = builds.filter(b =&gt; &#123; return filters.some(f =&gt; b.output.file.indexOf(f) &gt; -1 || b._name.indexOf(f) &gt; -1) &#125;)&#125; else &#123; // 默认过滤weex builds = builds.filter(b =&gt; &#123; return b.output.file.indexOf('weex') === -1 &#125;)&#125;// 最终得到我们需要编译的，然后调用build函数。build(builds)function build (builds) &#123; let built = 0 // 计数器 const total = builds.length // 定义了一个next方法，当next执行时就调用buildEntry const next = () =&gt; &#123; buildEntry(builds[built]).then(() =&gt; &#123; built++ if (built &lt; total) &#123; next() &#125; &#125;).catch(logError) &#125; next()&#125;// 此处的config参数就是builds[built]，也就是作为最终rollup所编译需要的configfunction buildEntry (config) &#123; const output = config.output const &#123; file, banner &#125; = output const isProd = /(min|prod)\.js$/.test(file) // 出口文件（dest）是否以min或prod.js结尾（是否是生产环境） return rollup.rollup(config) .then(bundle =&gt; bundle.generate(output)) // config编译完后拿到bundle, bundle通过generate生成output .then((&#123; output: [&#123; code &#125;] &#125;) =&gt; &#123; // output对应我们生成的目标 if (isProd) &#123; // 如果是生产环境就再做一次压缩 // 可能会对code做一些修改，比如说判断是否需要压缩 const minified = (banner ? banner + '\n' : '') + terser.minify(code, &#123; toplevel: true, output: &#123; ascii_only: true &#125;, compress: &#123; pure_funcs: ['makeMap'] &#125; &#125;).code // 最终调用write return write(file, minified, true) &#125; else &#123; return write(file, code) &#125; &#125;)&#125;function write (dest, code, zip) &#123; return new Promise((resolve, reject) =&gt; &#123; function report (extra) &#123; // 生成过程中可以打印一些log信息 console.log(blue(path.relative(process.cwd(), dest)) + ' ' + getSize(code) + (extra || '')) resolve() &#125; // 生成文件到dist目录下 fs.writeFile(dest, code, err =&gt; &#123; if (err) return reject(err) if (zip) &#123; zlib.gzip(code, (err, zipped) =&gt; &#123; if (err) return reject(err) report(' (gzipped: ' + getSize(zipped) + ')') &#125;) &#125; else &#123; report() &#125; &#125;) &#125;)&#125; 参考：process.argvfs.writeFile(file, data[, options], callback) Runtime Only 与 Runtime Compiler通常使用vue-cli脚手架去初始化项目的时候就会询问我们是使用Runtime Only版本，还是 Runtime Compiler版本。 Runtime Only 在使用Runtime Only版本时，通常要借助webpack与vue-loader把vue文件编译成JavaScript（因为在浏览器端是不认识.vue文件的，所以需要进行一次编译）。 在编译过程中，会把template模板编译成render函数，所以说，最终编译后的是一个render函数版本。 因为这些行为都是在编译阶段进行的，编译行为也是在离线时做的，所以Runtime Only只包括运行时的Vue.js代码，相比Runtime Compiler体积更加轻量。 Runtime Compiler Runtime Compiler不对代码做预编译，所以当使用Runtime Compiler版本时，自然不可以用.vue文件，不过我们可以在代码里使用template模板。 现在的Vue(2.x)，最终渲染都是通过render函数，所以如果我们使用了template属性，Vue在运行时就会动态地把模板编译成render函数。 123456789101112// 需要编译new Vue(&#123; template: '&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;'&#125;)// 不需要new Vue(&#123; render(h) &#123; return h('div', this.message) &#125;&#125;) 因为编译过程肯定会有一些性能损耗，所以通常在开发阶段都推荐用runtime only版本，一个是为了运行时的性能优化，一个是编译出的vuejs体积也会小很多。 猫片福利]]></content>
      <tags>
        <tag>notes</tag>
        <tag>vue</tag>
        <tag>source-code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摆脱对正则表达式的恐惧吧！走进 JavaScript 中的正则表达式]]></title>
    <url>%2F2020%2F04%2F02%2FRegExp%2F</url>
    <content type="text"><![CDATA[我相信每个成熟稳健的程序员（滑稽），都有一段与正则相爱相杀的经历。在我第一次接触正则的时候，它在我眼中就是一串乱码，完全不知道发生了什么，但是当你你了解正则表达式的套路之后，其实正则就是一种用来检索或查找字符的文字模板。简单来说，正则表达式将某个字符串模式将所搜索的字符串进行匹配，如果匹配成功，它所匹配到的内容一定是字符串中的内容。 ❗️正则表达式的概念并不是JavaScript中独有的，例如Java、PHP等等，本文只探讨JavaScript中的正则。 走进正则与Array、Object等类似，我们同样可以使用两种形式去写正则，一种是使用字面量形式，另一种是使用构造函数，我们先来看一个简单的例子。 字面量写法123const str = 'Boom Shakalaka';const pattern = /Boom/;console.log(pattern.test(str)); // true 构造函数写法123const str = 'Boom Shakalaka';const pattern = new RegExp('Boom');console.log(pattern.test(str)); // true 我们想检测’Boom Shakalaka’这个字符串中是否包含’Boom’这个字符串，在这里我们使用了test()方法，test()方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。很显然，’Boom Shakalaka’中包含了’Boom’，所以我们打印出的值为true。 我们同样可以使用exec()方法来进行检测，exec() 方法返回一个数组，完全匹配成功的文本将作为返回数组的第一项，从第二项起，后续每项都对应正则表达式内捕获括号里匹配成功的文本。1234const str = 'Boom Shakalaka';const pattern = new RegExp('Boom');console.log(pattern.exec(str));// ["Boom", index: 0, input: "Boom Shakalaka", groups: undefined] 模式修饰符还是刚刚那个例子，我们做一点小改动，把Boom改成boom。123const str = 'Boom Shakalaka';const pattern = /boom/;console.log(pattern.test(str)); // false, 此时并没有匹配到。 默认情况下，正则是区分大小写的，如果我们想不区分大小写去匹配字符的话，就需要使用正则中的模式修饰符。123const str = 'Boom Shakalaka';const pattern = /boom/i;console.log(pattern.test(str)); // true 这里我们用到了模式修饰符“i”, i表示ignore case, 也就是忽略大小写，其余的模式修饰符还有g: global 全局匹配，m: multiline 多行匹配。 ⭐️这三个字符可以随意进行组合。 构造函数写法123const str = 'Boom Shakalaka';const pattern = new RegExp('boom', 'i');console.log(pattern.test(str)); // true 字符类在之前我们所接触的例子中，正则表达式的一个字符对应了字符串中的一个字符，如果我们想在’fsaxcvbn’中选出’abc’中的任意一个字符的话，替换成“*”号，这样的场景下，我们可以使用字符类来实现。123const str = 'fsaxcvbn';const pattern = /[abc]/g; // 用到了模板修饰符中的全局匹配console.log(str.replace(pattern, '*')); // fs*x*v*n 在上面这个例子中，我们使用[]来构建一个简单的类，类中把a/b/c归为了一类，代表可以匹配这一类中的字符，由此可见，所谓类是指符合某些特性的一个泛指，而不是特指某一个字符。 反向字符类我们可以在类的开头加一个“^”符号，来表示匹配除当前字符类以外的字符。123const str = 'fsaxcvbn';const pattern = /[^abc]/g; // 用到了模板修饰符中的全局匹配console.log(str.replace(pattern, '*')); // **a*c*b* 范围类如果我们想匹配全部的字母，来转化为“*”符合，那么我们的字符类中就要输入26个字母，那样的话未免也太长了，而且容易出错，所以我们可以使用范围类去给定一个范围，代表我们要匹配这个范围内的文字。123const str = 'DIO：我不做人了JOJO';const pattern = /[a-z]/gi;console.log(str.replace(pattern, '*')); // ***：我不做人了**** 当然，[A-Z][c-e][0-9][\u4e00-\u9fa5]或者组合使用[a-z0-9@_]都是可以的，只不过使用范围类有一个原则，就是前面的范围起点一定要小于等于后面的范围终点（例如[z-a]），不然就会报错。 元字符正则中有一种具有特殊意义的字符，叫作元字符，例如^/b/w，很多人刚接触正则时觉得一脸懵*大概率都是元字符的锅。 打个比方，如果我们想匹配字母、数字、下划线的情况下，就可以用元字符\w来代替，与之相对，如果我们想匹配除字母、数字、下划线以外的字符，我们可以用\w的反义\W去匹配。 下面来看一些常用的元字符。 元字符 描述 . 匹配除换行符和行结束符以外的所有字符 \w 匹配0-9、a-z、A-Z \W 与\w相反，匹配非0-9、a-z、A-Z的字符 \d 匹配0-9，等同于[0-9] \D 匹配除0-9以外的字符，等同于0-9 \n 匹配换行符 \s 匹配空格与制表符 \S 匹配除空格与制表符外的所有字符 \t 匹配制表符 \b 匹配单词边界 \B 匹配非单词边界 ^ 匹配字符串起始位置 $ 匹配字符串结束位置 \xnn 由16进制数nn指定的拉丁字符(eg.\x0A&lt;=&gt;\n) \uxxxx 由16进制数xxxx指定的Unicode字符(eg.\u0009&lt;=&gt;\t); 常用来匹配汉字 注意此处的^与中的^意思不同，此处的^指代字符串起点。中文字符的元字符范围是[\u4e00-\u9fa5]。 来看一个使用元字符的简单例子。 123const str = ' 1哈哈哈';const pattern = /[\s\d]/g //全局匹配空格或数字console.log(str.replace(pattern, '~')); // ~~哈哈哈 字符转义元字符其实就是被赋予了特殊意义的字符，如果我们想要去匹配元字符本身的字符，比如“.”，就没法使用“.”来匹配了，它会被解释成别的意思，这时候就需要用转义字符“/”来取消这类特殊字符的意义，我们该去用“/.”去查找“.”。当然，如果想查找“/”本身，我们也需要用“//”。 123const str = '好吧...';const pattern = /\.+/console.log(str.replace(pattern, '😭')); // 好吧😭 我们上面的“…”被替换成了emoji表情，变成了“好吧😭”，我们之前说过，正则中的一个字符对应了字符串中的一个字符，我们之所以可以把三个“.”替换成一个“😭”，是因为我们使用了正则表达式中的限定符“+”。 重复（限定符）顾名思义，限定符就是用来限定正则表达式所匹配的字符出现了多少次才能匹配成功的字符。 限定符 描述 {n} 重复n次 {n,} 重复n次或重复大于n次 {n,m} 重复n到m次 + 重复一次或多次，等同与{1,} ？ 重复0次或1次，等同与{0,1} * 重复任意次（0或多次），等同与{0,} 12345678910111213141516171819202122232425const str = '0123456789';const pattern = /\d&#123;3&#125;/ // 匹配3次console.log(pattern.exec(str));// ["012", index: 0, input: "0123456789", groups: undefined]const pattern2 = /\d&#123;1,&#125;/ // 匹配1次或以上console.log(pattern2.exec(str));// ["0123456789", index: 0, input: "0123456789", groups: undefined]const pattern3 = /\d&#123;3,5&#125;/ // 匹配3-5次console.log(pattern3.exec(str));// ["01234", index: 0, input: "0123456789", groups: undefined]const pattern4 = /\d?/; //匹配0次或1次 /\d&#123;0,1&#125;/console.log(pattern4.exec(str));// ["0", index: 0, input: "0123456789", groups: undefined]const pattern5 = /\d+/; //至少匹配1次 /\d&#123;1,&#125;/console.log(pattern5.exec(str));// ["0123456789", index: 0, input: "0123456789", groups: undefined]const pattern6 = /\d*/; //零次或更多console.log(pattern6.exec(str));// ["0123456789", index: 0, input: "0123456789", groups: undefined] 最近因为疫情在家一直在吃外卖，我们写个小例子来尝试匹配下外卖的价格。1234const str = '外卖套餐: $15.5';const pattern = /\d+\.?\d*/console.log(pattern.exec(str));// ["15.5", index: 7, input: "外卖套餐: $15.5", groups: undefined] 我们来分析下这段正则，首先我们要匹配1位以上的数字，所以用/d+，并且价格不一定是一个整数，也有可能是小数，所以用转义字符加上小数点“.”，后跟上“?”表示0次货或1次，紧接着跟小数点后n位数字，这个数字有可能是0位也有可能是多位，所以用“\d*”。 上面这段正则等价于 ↓↓1const pattern = /\d&#123;1,&#125;\.&#123;0,1&#125;\d&#123;0,&#125;/; 非贪婪的重复正则在默认情况下都是贪婪的，也就是说，只要条件允许，正则都会尽可能多的去匹配，如果我们想尽可能少去匹配，就需要使用一个“?”把正则转化成非贪婪匹配。 看一个小例子。12345678910const domStr='&lt;td&gt;&lt;p&gt;a&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;b&lt;/p&gt;&lt;/td&gt;';const patternDom = /&lt;td&gt;.*&lt;\/td&gt;/;console.log(patternDom.exec(domStr));// 会一直匹配到最后// ["&lt;td&gt;&lt;p&gt;a&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;b&lt;/p&gt;&lt;/td&gt;", index: 0, input: "&lt;td&gt;&lt;p&gt;a&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;b&lt;/p&gt;&lt;/td&gt;", groups: undefined]const patternDom2 = /&lt;td&gt;.*?&lt;\/td&gt;/;console.log(patternDom2.exec(domStr));// 变成了尽可能少的匹配// ["&lt;td&gt;&lt;p&gt;a&lt;/p&gt;&lt;/td&gt;", index: 0, input: "&lt;td&gt;&lt;p&gt;a&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;b&lt;/p&gt;&lt;/td&gt;", groups: undefined] 选择、分组与反向引用选择正则里的选择（也可以叫分支条件）表示的是我们给出几种不同的规则，当符合任意一种规则时，都算作匹配成功，我们可以用一个管道符“|”划分规则。1234const str = 'Hello world';const pattern = /universe|world/console.log(pattern.exec(str));// ["world", index: 6, input: "Hello world", groups: undefined] 分组如果说限定符可以重复单个字符，那么使用粉组件就可以重复多个字符。1234const str = 'abab';const pattern = /(ab)+/;console.log(pattern.exec(str));// ["abab", "ab", index: 0, input: "abab", groups: undefined] 此时我们发现匹配到了“abab”，并且返回数组的第二个索引位置为“ab”，我们上文有讲过，exec()方法返回一个数组，完全匹配成功的文本将作为返回数组的第一项，从第二项起，后续每项都对应正则表达式内捕获括号里匹配成功的文本。此处的捕获括号，指的就是分组，所以第二个索引返回的是分组里的“ab”。 非捕获分组但有些时候我们不希望分组内的东西被捕获到，这种时候我们就可以使用非捕获性分组(?:)，然后对着括号里的字符说一句“你不配。”1234const str = 'abcd';const pattern = /(?:ab)c/;console.log(pattern.exec(str));// ["abc", index: 0, input: "abcd", groups: undefined] 由此可见，此时并没有匹配分组中的ab。 嵌套分组1234const str = 'abcd';const pattern = /(a(b(c)))/;console.log(pattern.exec(str));// ["abc", "abc", "bc", "c", index: 0, input: "abcd", groups: undefined] 我们可能会遇上分组里再次进行分组的正则，这种正则叫作嵌套分组，嵌套分组乍一看很乱，不过只要从左开始数左括号就可以了。 反向引用在我们使用()指定一组分组时，在默认情况下，每个分组都会拥有一个组号，组好以1为起点，从左往右数，第一个分组的组号为1，第二个为2，以此类推。我们可以使用组号去引用它对应的分组。 假定我们要匹配的字符串是一个有嵌套关系的HTML标签字符串，例如1&lt;div&gt;&lt;p&gt;Hi ~~&lt;/p&gt;&lt;/div&gt; 但是我们不知道最外层的标签是什么，我们该怎样去写这个正则呢？1const pattern = /&lt;([a-zA-Z]+)&gt;(.*)&lt;\/([a-zA-Z]+)&gt;/; 首先，我们写上&lt;&gt;, 标签可能是大写也可能是小写，所以我们用了一个字符类[a-zA-z]来匹配，并且用限定符“+”匹配1位及以上的字母，然后用第二个分组(.*)来表示之间的所有内容，证明有0个或多个除换行符和空格以外的字符，最后使用转义字符结尾。 在上面那个例子中，我们同一个分组([a-zA-Z]+)在正则中写了两次，这种虽然可以匹配上，但是不美观，也更容易出错，这时候我们可以使用刚刚提起的引用来改写一下。1const pattern = /&lt;([a-zA-Z]+)&gt;(.*)&lt;\/\1&gt;/; 此处使用了引用符号“\1（需要转义字符）”来匹配与第一个分组相同的字符，此时结尾处所匹配上的字符一定等同于第一个分组所匹配到的字符。 零宽断言与负向零宽断言零宽断言用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。正向零宽断言(零宽度正预测先行断言)与负向零宽断言(零宽度正回顾后发断言)也叫前瞻性匹配与负向前瞻性匹配，这些名字挑一个自己喜欢的叫吧，因为我也记不住那么多，哈哈哈 ~。 正向零宽断言正向零宽断言用(?=)来表示匹配后面跟xx字符的前字符，听着有点乱是不是，来看一个小例子。1234const str='java javascript';const pattern = /java(?=script)/;console.log(pattern.exec(str));// ["java", index: 5, input: "java javascript", groups: undefined] 我们匹配到了java，但我们匹配到的java并不是第一个java，而是javascript中的“java”，匹配以“script”结尾的“java”。 屏幕前的小机灵鬼，就是你！此刻肯定想到了与之相反的就是负向零宽断言，你猜对了，我们来看一下。 负向零宽断言负向的零宽断言用(?!)来表示，匹配后面不接xx字符的前字符。1234const str='java javascript';const pattern = /java(?!script)/;console.log(pattern.exec(str));// ["java", index: 5, input: "java javascript", groups: undefined] 此时匹配到的java是第一个java，不再是javascript中的java了。 RegExp对象的实例属性1234567const str='Hello world Hello';const pattern=/hello/ig;console.log(pattern.ignoreCase); // 判断有没有iconsole.log(pattern.global); // 判断有没有gconsole.log(pattern.multiline); // 判断有没有mconsole.log(pattern.source); // 返回字面量对应形式对应的字符串console.log(pattern.lastIndex); // 返回字面量对应形式对应的字符串 lastIndex属性我们可能会对lastIndex有一点疑问，当正则表达式使用 “g” 修饰符时，可以多次执行 exec()方法来查找同一个字符串中的成功匹配。当你这样做时，查找将从正则表达式的 lastIndex 属性指定的位置开始。（test() 也会更新 lastIndex 属性）。注意，即使再次查找的字符串不是原查找字符串时，lastIndex 也不会被重置，它依旧会从记录的 lastIndex 开始。 翻译一下，就是当我们在非全局匹配的模式下，exec()方法只会匹配第一个匹配到的字符，但是，如果我们在全局匹配下，则可以循环使用exec()方法来得到所有的匹配，直到exec()的返回值变为null为止，再次使用exec()会执行新一轮的查找匹配。我们之所以可以使用exec()方法循环匹配，靠的就是lastIndex的值，因为带全局修饰符的正则表达式每次匹配后都会更新lastIndex的值作为下次查找匹配的起点，即使我们查找的字符串发生改变，lastIndex也不会被重置。 1234567891011121314151617181920212223242526272829303132333435let str='js js js';const pattern=/js/g; //全局console.log(pattern.exec(str));console.log(pattern.lastIndex);// ["js", index: 0, input: "js js js", groups: undefined]// 2// index为0表示从索引为0的位置匹配到“js”, 2表示下次查找的起点索引// 以此类推console.log(pattern.exec(str));console.log(pattern.lastIndex);// ["js", index: 3, input: "js js js", groups: undefined]// 5console.log(pattern.exec(str));console.log(pattern.lastIndex);// ["js", index: 6, input: "js js js", groups: undefined]// 8console.log(pattern.exec(str));console.log(pattern.lastIndex);// null// 0// 没有找到，重置lastIndexconsole.log(pattern.exec(str));console.log(pattern.lastIndex);// ["js", index: 0, input: "js js js", groups: undefined]// 2str='js Hello js'; // 改变字符串console.log(pattern.exec(str));console.log(pattern.lastIndex);// ["js", index: 9, input: "js Hello js js", groups: undefined]// 11 索引并未重置 构造函数属性与RegExp对象的实例属性不同，构造函数属性不常用，存在一定的兼容问题，这边了解即可。 ❗️注意，构造函数属性一定要是调用了exec()或者test方法，我们的构造函数属性才会有值。1234567891011121314const str='js js js';const patternFn=/(j)s/;patternFn.exec(str);console.log(RegExp.input);console.log(RegExp.$_); // 等于inputconsole.log(RegExp.lastMatch);// 最后一次匹配到的字符console.log(RegExp['$&amp;']); // lastIndex的别名 ,但是因为不符合标识符规则(字母/_/$开头,后面可以字母/_/$/数字),所以只能用这种形式console.log(RegExp.leftContext); // 上一次匹配左边剩余的字符console.log(RegExp['$`']); //↑别名console.log(RegExp.rightContext); // 上一次匹配右边剩余的字符console.log(RegExp["$'"]); // ↑别名console.log(RegExp.lastParen); // 分组捕获内容console.log(RegExp['$+']); // ↑别名console.log(RegExp.$1); // 分组字符 === /\1\2/ String对象中的正则匹配String对象为我们提供了4种方法用于匹配正则，分别是replace()、search()、match()、split()。 replace() replace() 方法返回一个由替换值（replacement）替换一些或所有匹配的模式（pattern）后的新字符串。模式可以是一个字符串或者一个正则表达式，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。 也就是说，你可以用replace()方法把原字符串中匹配到的字符转换成你需要的字符，并且replace()方法返回这个新的字符串，话不多说，来看例子。 模式可以是一个字符串或者一个正则表达式 ↓↓123456const str = 'I love JOJO, jojo, JoJo';const pattern = /JOJO/ig;console.log(str.replace(pattern, 'DIO'));// I love DIO, DIO, DIOconsole.log(str.replace('JOJO', 'DIO'));// I love DIO, jojo, JoJo 替换值可以是一个字符串或者一个回调函数，替换纸是字符串的例子我们上面已经看过了，来看一下回调函数的写法。构造函数接收4个参数，分别是match(匹配到的字符串)，p1,p2..（对应的分组字符），offset(匹配到的字符串在原字符中的偏移量)，string（被匹配的原字符串）。1234567const str = 'I love JOJO';const pattern = /(J)OJO/;str.replace(pattern, (match, p1, offset, string) =&gt; &#123; console.log(match, p1, offset, string); // JOJO J 7 I love JOJO return 'DIO'&#125;); ❗️注意，原字符串还是’I love JOJO’, replace()并不会改变原字符串。 search()search()方法可以传入一个字符串或者一个正则表达式，它返回匹配到的位置，-1为未匹配到。1234const str = 'I love JoJO, jojo, JoJo';const pattern = /JOJO/ig;console.log(str.search(pattern));// 7 我们发现，search()方法只匹配了第一个“JOJO”，也就是说，无论有没有全局修饰符“g”，对search()方法都没有影响，search()方法只要找到一个对应的匹配就会立刻返回。如果我们传入的是字符串，search()方法会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象再进行匹配。 match()match()方法与exec()方法比较类似，都会返回一个数组，区别在于全局匹配的时候。 1234567891011121314const str = 'JOJO JOJO JOJO';// 先来看一下非全局匹配const pattern = /(J)OJO/;console.log(pattern.exec(str));// ["JOJO", "J", index: 0, input: "JOJO JOJO JOJO", groups: undefined]console.log(str.match(pattern));// ["JOJO", "J", index: 0, input: "JOJO JOJO JOJO", groups: undefined]// 再来看一下全局匹配const patternG = /(J)OJO/g;console.log(patternG.exec(str));// ["JOJO", "J", index: 0, input: "JOJO JOJO JOJO", groups: undefined]console.log(str.match(patternG));// ["JOJO", "JOJO", "JOJO"] 在非全局匹配时，可以看出match()的结果和exec()并没有什么区别，但是在全局匹配时就不一样了，match()会一次性把匹配项都抓取出来，但是并不会抓取分组中的字符。 match: 非全局/g匹配的情况下才会返回分组中匹配到的内容, 全局匹配只能匹配到所有匹配到的字符。exec: 无论是否全局匹配都会返回分组中匹配到的内容, 都只会返回当前匹配到的一个内容, 而不是全部返回, 但是在全局匹配的时候是可以继续匹配，直到找不到为止。 split()split()方法使用指定的分隔符字符串将一个String对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。我们可以往里面传入一个字符串作为分隔字符，也可以传入一个正则表达式去作为分隔字符来拆分字符串。 那什么场景下我们使用正则表达式来作为分隔字符比较好呢。12345678const splitStr = ' Hi , Hi , Hi ';const splitPattern = /,/;console.log(splitStr.split(splitPattern));// [" Hi ", " Hi ", " Hi "]// 这样会有很多空格,这时候就需要使用正则了const splitPattern2 = /\s*,\s*/;console.log(splitStr.split(splitPattern2));// 消除空格 [" Hi", "Hi", "Hi "] 正则练习到此为止，正则应该已经在你脑海里有了一个大体的形状，下面来看几个小例子，看一下正则在日常开发中的常见用法。 连字符转转驼峰我们一般写css的时候，比如“background-color”，到了js里就会变成用“backgroundColor”去获取元素的背景颜色属性，“background-color”的这种书写方式叫作连字符形，而“backgroundColor”这种就叫作驼峰型，我们来写一个正则，把连字符形式转成驼峰形式。 12345const str = 'background-color'const pattern=/-([a-z])/i;str.replace(pattern,function($1, $2)&#123; return $2.toUpperCase();&#125;) // backgroundColor 邮箱验证我们先来分析一下邮箱的常用格式 rachellssr@gmail.comrachellssr123@gmail.com.cnrachellssr_123@gmail.com.cnrachellssr_123.com@gmail.com.cn 这几种都是有可能的。 12const email = '^%$#@asda.com'const pattern = /(?:\w+\.)*\w+@(?:\w+\.)+[a-z]*/i; (?:\w+.) → xx.xx. 都是类似的结构，可以把他们写成一个分组。这样的分组可能有很多也可能一个都没有，所以需要用“” \w+@ → 邮箱肯定存在一个不带特殊字符的字符串，可能是字母数字下划线，并且用一个@连接邮箱域名 (?:\w+.)+ → 在邮箱的域名中 xx.这样的格式至少有一组，所以用“+” [a-z] → 有可能是“.com.cn”类型的结尾，所以最后用[a-z]。 好了，到这里这篇博客的内容就算全部结束了，写这篇博客的初衷也是想给自己做一个总结，平时工作不用正则的时候总是容易忘，但是在一些大型项目里，正则真的是随处可见，如果这篇文章能对你有一点点帮助那真是再好不过啦 ~ 闲聊一眨眼半年没有更新博客了，因为一些个人发展原因，我来到了新的城市。这半年发生了许多事，也非常忙，忙到让我根本感觉不到时间的流逝，刚来到陌生城市的时候，不同的城市节奏、环境的改变、不熟悉的项目等等，都让刚刚跳出舒适区的我感到焦虑，那时候觉得每个人都好忙碌，自己却格格不入，所以那时没有调整好自己的心态，更没有办法静下心来去写一些东西。 不过事实证明，人的适应能力是很强的，现在我也变成了这个忙碌城市的一份子，曾经偶尔十二点下班就觉得加班很累了，到新城市后995变成了常态，凌晨下班的次数一只手也数不过来。不过我一点也不后悔换了城市，因为自己这半年时间，真的成长了很多，技术上也是，生活上也是，有句话不是说“一切都是最好的安排。”吗，就是那样，虽然2020年的开年不完美，但也希望每个看到这段话的人，不要忘记自己的初衷，努力快乐的生活。 最近没有看什么好看的动漫，一个是因为忙，再有就是因为疫情的原因很多番都推迟上线了，比如RE0。不过一个人生活之后我养猫啦 ~ 放宝贝镇楼。]]></content>
      <tags>
        <tag>categories</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带你上手react-redux+代码示例]]></title>
    <url>%2F2019%2F07%2F18%2Freact-redux2%2F</url>
    <content type="text"><![CDATA[我之前在写「一步步带你入门Redux状态管理」这篇文章时提到过，react-redux才是专门为React服务的状态管理插件。 如果你之前没有读过这篇文章，我强烈建议你在读过这篇文章后，再来学习react-redux。因为如果要做比喻的话，Redux才是基石，而react-redux就像为 Redux锦上添花一样的存在。 简单来说，react-redux实际上就是一个第三方的模块，帮助我们在react之中更加方便的使用redux。 安装react-redux并不是 Redux 内置，需要单独安装。 所以我们需要安装redux以及react-redux。 安装redux npm安装 yarn安装 npm install —save redux yarn add redux 安装react-redux npm安装 yarn安装 npm install —save react-redux yarn add react-redux 代码部分我想实现一个todoList功能，当我点击提交按钮的时候，在input下面会增加我刚刚输入的内容。 目录 store&gt;index.js123456import &#123; createStore &#125; from 'redux';import reducer from './reducer';const store = createStore(reducer);export default store; store&gt;reducer.js12345678const defaultState = &#123; inputValue: 'Rachel', list: [] // list列表显示的值&#125;export default (state = defaultState, action) =&gt; &#123; return state; &#125; actionCreators.js和actionTypes.js暂时先不管。 src&gt;index.js1234567891011121314import React from 'react';import ReactDOM from 'react-dom';import TodoList from './TodoList';import &#123; Provider &#125; from 'react-redux';import store from './store';const App = ( &lt;Provider store=&#123;store&#125;&gt; &#123;/* 1.把TodoList写在Provider里 */&#125; &lt;TodoList /&gt; &lt;/Provider&gt;)// 2.把App作为组件传给ReactDOM.render(),实际上我们整个页面要渲染的是一个APP组件ReactDOM.render(App, document.getElementById('root')); API-Provider此时出现了react-redux的第一个核心API——Provider，来看一下它的官方解释。 先忽略这里面提到的connect方法，我来解释一下Provider的作用。 Provider顾名思义，提供者。Provider去连接store, 之后Provider内所有的子组件都有能力获取到store里面的内容。也就是说，Provider作为一个提供者，把store的数据提供给了所有子组件。 用法如上，Provider作为一个包裹组件使用，包裹在其他组件的最外层。 此时我们的TodoList组件已经可以获取store里的全部内容了。 src&gt;TodoList.js1234567891011121314151617181920212223242526272829303132import React, &#123; Component &#125; from 'react';import &#123; connect &#125; from 'react-redux';class TodoList extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;input type="text" value=&#123;this.props.inputValue&#125;/&gt; &lt;button&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;li&gt;Song&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;const mapStateToProps = (state) =&gt; &#123; // 参数state，指store里的数据 return &#123; inputValue: state.inputValue, &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(TodoList); API-connectreact-redux的第二个核心API——connect，官方解释如下。 connect翻译过来就是连接。从TodoList.js里的代码可以看出，connect是让TodoList组件和store做连接。其中依靠mapStateToProps做这个连接的映射，把store里的数据映射给这个组件，变成组件的props。 我们这个例子中，store里的inpuValue会映射到组件里的props的inputValue, 所以input取的是value值为this.props.inputValue。 如果我们想对store的数据做修改，那么我们就要通过mapDispatchToProps这个函数，把store.dispatch方法挂载到props上。 光看概念或许会有点蒙，但步骤不多，你现在只需把mapStateToProps理解为所需的数据，把mapDispatchToProps理解为我们要做的动作，带着这个概念去往下看代码，不知不觉间一定会豁然开朗。 我们想在input框输入内容的时候，让input框的值与我们输入的内容相同。首先在input上添加一个onChange事件，与此同时提出props常量（这一步可省略，不过因为后面还会多次使用，我们应当避免输写重复的代码，所以建议提出）。 1234567891011121314151617class TodoList extends Component &#123; render() &#123; const &#123; inputValue, changeInputValue &#125; = this.props; //提取props return ( &lt;div&gt; &lt;div&gt; &#123;/* 因为我们单独提取出了props，所以可以不再使用this.props.inputValue，变为直接使用inputValue与changeInputValue↓↓ */&#125; &lt;input type="text" value=&#123;inputValue&#125; onChange=&#123;changeInputValue&#125; /&gt; &lt;button&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;li&gt;Song&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 其次在mapDispatchToProps里添加changeInputValue方法。12345678const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; changeInputValue(e) &#123; const value = e.target.value; console.log(value); &#125;, &#125;&#125; 此时当我们输入内容的时候，虽然页面上不会渲染，但我们已经可以打印出input内的值了（这一步可以自行测试一下），下一步我们要去派发action。 actionTypes.js12// 统一常量，减少因重复拼写所可能产生的bugexport const CHANGE_INPUT_VALUE = 'change_input_value'; actionCreators.js1234567// 统一action, 优点: 提高代码可维护性, 对自动化测试也更方便import &#123; CHANGE_INPUT_VALUE &#125; from './actionTypes';export const getInputValue = (value) =&gt; (&#123; type: CHANGE_INPUT_VALUE, value&#125;); reducer.js1234567891011121314import &#123; CHANGE_INPUT_VALUE &#125; from './actionTypes';const defaultState = &#123; inputValue: 'Rachel', list: []&#125;export default (state = defaultState, action) =&gt; &#123; if (action.type === CHANGE_INPUT_VALUE) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; &#125; return state;&#125; 最后修改TodoList.js12345678910111213// 引用actionCreatorsimport &#123; getInputValue &#125; from './store/actionCreators';// 修改mapDispatchToPropsconst mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; changeInputValue(e) &#123; const value = e.target.value; const action = getInputValue(value); dispatch(action); &#125;, &#125;&#125; 此时我们在input里已经可以自由输入，输入的内容也会渲染在页面上了。下面再来加上提交功能，提交的每一项会存入store，然后再由mapStateToProps映射给props，从而显示在页面上。 步骤同上，直接贴最终代码。 actionTypes.js12export const CHANGE_INPUT_VALUE = 'change_input_value';export const ADD_ITEM = 'add_item'; actionCreators.js12345678910import &#123; CHANGE_INPUT_VALUE, ADD_ITEM &#125; from './actionTypes';export const getInputValue = (value) =&gt; (&#123; type: CHANGE_INPUT_VALUE, value&#125;);export const getAddItemAction = () =&gt; (&#123; type: ADD_ITEM&#125;); reducer.js1234567891011121314151617181920import &#123; CHANGE_INPUT_VALUE, ADD_ITEM&#125; from './actionTypes';const defaultState = &#123; inputValue: 'Rachel', list: []&#125;export default (state = defaultState, action) =&gt; &#123; if (action.type === CHANGE_INPUT_VALUE) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; &#125; if (action.type === ADD_ITEM) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.list.push(newState.inputValue); newState.inputValue = ''; return newState; &#125; return state;&#125; TodoList.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123; Component &#125; from 'react';import &#123; connect &#125; from 'react-redux';import &#123; getInputValue, getAddItemAction &#125; from './store/actionCreators';class TodoList extends Component &#123; render() &#123; const &#123; inputValue, changeInputValue, handleClick, list &#125; = this.props; return ( &lt;div&gt; &lt;div&gt; &lt;input type="text" value=&#123;inputValue&#125; onChange=&#123;changeInputValue&#125;/&gt; &lt;button onClick=&#123;handleClick&#125;&gt;提交&lt;/button&gt; &lt;ul&gt; &#123; list.map((item, index) =&gt; &#123; return ( &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;/li&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; inputValue: state.inputValue, list: state.list &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; changeInputValue(e) &#123; const value = e.target.value; const action = getInputValue(value); dispatch(action); &#125;, handleClick() &#123; const action = getAddItemAction(); dispatch(action); &#125;, &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(TodoList); 其余代码不变，当点击提交的时候，我们通过mapDispatchToProps关联了store里的dispatch方法，向store派发了一个名为getAddItemAction的action（这个action放在actionCreators管理），当store接收到这个action的时候，store会去reducer里找这个值，之后store拿着从reducer中处理返回的值，再通过mapStateToProps映射到组件上，以此完成了TodoList功能。 总结相比redux，我们不需要再在文件内再引用store, connect会自动帮我们做连接。数据一旦发生改变, 组件也会跟着变(因为connect做了连接), 也不再需要store.subscribe()再去做订阅。 推荐阅读1、yarn构建react项目2、一步步带你入门Redux管理数据 然后~ 说点题外话，我又来安利动画啦~~hhh，今天安利的是「强风吹拂」。 虽然和上次安利的排球少年有相似之处，可强风吹拂更像是一股清风，慢慢的吹进了你的心里，赋予你勇气与力量，让你感到未来可期💚。]]></content>
      <tags>
        <tag>categories</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yarn构建react项目]]></title>
    <url>%2F2019%2F05%2F15%2FbuildReact%2F</url>
    <content type="text"><![CDATA[前言我个人比较喜好用yarn开发，速度比较快，并且还有许多优势，这边不做过多介绍。你如果习惯直接使用npm，可跳过这步，直接去安装react官方脚手架Create-react-app。 搭建react开发环境安装yarn1npm install -g yarn 安装react官方脚手架Create-react-app npm直接安装 yarn安装 npm install -g create-react-app npm install create-react-app yarn -g 创建一个叫new-project的项目1create-react-app new-project ❗️注意项目名不可包含大写字母 运行项目 npm运行 yarn运行 npm start yarn start 运行后如下图。]]></content>
      <tags>
        <tag>categories</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步步带你入门Redux管理数据]]></title>
    <url>%2F2019%2F05%2F15%2Freact-redux%2F</url>
    <content type="text"><![CDATA[闲聊最近忙里偷闲学习了react。由于之前一直都是使用vue做项目，所以学习react的时候觉得既熟悉又陌生。 熟悉是因为它和vue拥有许多相似的概念，包括都推崇组件化、都拥有’props’的概念、核心都是视图层框架等等。虽然react不像vue拥有那么多丰富的API，但是在我看来，正因为react本身没有过度的封装，再加上react的社区非常成熟与活跃，才使得react的开发灵活多变，相比起来，我觉得react更适合大型项目的开发，react的函数式编程也更容易实现前端自动化测试。 尤大自己也说过vue从一开始的定位就是尽可能的降低前端开发的门槛，让更多的人能够更快地上手开发。所以学习起来，vue更加圆滑，而react相对陡峭。两者在我看来都是非常优秀的框架，没有高低之分，我们可以根据不同的开发情况选择不同的开发工具。 前言今天主要是想写一下如何在react中管理数据。我会从搭建react项目开始，循序渐进，如果你对这其中的某些过程已经非常了解，可以在右侧的目录中跳过该章节。 在此之前，如果你还不了解该如何搭建react项目，请参考我的另一篇文章「yarn构建react项目」。 ReduxRedux=Reducer+Flux，Flux是Facebook推出的最原始的辅助React的数据层框架，但是它并不是那么的好用，所以有人把Flux做了一个升级，变成了Redux。 为什么要使用redux请看下面这张图 假设底部绿色的组件要和最顶层的组件通信，那么绿色的组件需要层层把消息转发给父级组件，直到传到最顶层的组件，如果我们项目中的组件非常之多，组件之间又经常需要共享传值的话，那么使用react这种父子通信的方式，整个项目的开发就会变得非常冗余，也不易维护。 前面说过，react是一个视图层框架（并不是什么问题都依靠react解决，react只解决数据和页面渲染——也就是搭建视图, 至于组件渲染交给别的数据层框架来做额外的支撑），所以我们需要一个数据层框架去协助react帮助数据管理，目前主流和react搭配的就是redux。 redux要求我们把数据都存放在一个名为store的公共存储区域，我们把数据都存放在store中。如果想通过绿色的组件改变数据传给其他组件，那么我们只需要操作store就可以了，接着其他灰色的组件会自动感知到变化，然后重新去store中取数据，这样我们取到的数据，就是刚刚绿色组件所更改的数据。也就是说，redux间接地帮我们实现了组件通信的功能，让我们的组件通信变得非常的轻松。 ❗️但是我们要知道，redux不是只为react服务的，而是为JavaScript服务的状态容器，react-redux才是专门为react服务的状态管理插件，本篇文章主要讲解redux。 redux 三大原则1.单一数据源store是唯一的。整个应用的数据被储存在一棵object tree(对象树)中，并且这个 object tree 只存在于唯一一个 store 中。 2.state是只读的唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 3.使用纯函数执行修改为了描述 action 如何改变 state tree ，你需要编写 reducers。reducer必须是纯函数: 纯函数是指给定固定的输入, 就一定会有固定的输出, 且不会有任何副作用; 一旦一个函数有一个settimeout或者ajax或者new Date相关内容的时候, 它就不是一个纯函数, 所以reducer里不可以有异步的操作。❗️副作用: 例如对参数的修改就是副作用, 这个时候reducer也就不是一个纯函数了 Mutabilit(可变性) &amp; Immutability(不变性)在学习redux前，我希望你可以了解Mutabilit(可变性)和Immutability(不变性)这两个概念。 首先从字面上理解，「可变」意味着可以出现变化，可以变化，就意味着可能会出现一些问题或是bug。 「不可变」就代表某些数据是不可修变的，如果想要改变不可变的数据，那么只能去复制旧的数据，再产生新的数据来取代旧的数据，我们永远不要去修改旧的数据。 我这里不做过多的赘述，如果你对这块有兴趣，可以去自行查找一些文章了解，本文只需要你了解这个概念。 redux的工作流程reactComponents： 每一个页面上的组件。actionCreators：管理action的地方。action：动作，它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store，通常是一个对象。store：存储数据的公共区域，也可以理解为把action和reducers联系到一起的对象。reducers：处理不同的action类型，告诉store该给组件什么样的数据，然后store再把这个数据给到对应的组件。 这里你或许会看的有点蒙，我下面用代码来解释一下redux的工作流程。 安装redux npm安装 yarn安装 npm install —save redux yarn add redux redux代码讲解 我想实现一个todoList功能，当我点击提交按钮的时候，在input下面会增加我刚刚输入的内容。其中，input和button是父组件，下面的ul是子组件。效果如下 基础结构-取值先在刚刚搭建好的react项目中的src文件下建立一个store文件夹（你也可以建在任何的组件文件夹下），在store里分别创建一个index.js和reducer.js。 reducer.js12345678910// 定义初始数据defaultState，如果不给state设置一个初始数据，那么最初state就是一个undefined。// 这里我已经为todoList写入了一个字符串inputValue和数组list。const defaultState = &#123; inputValue: '', list: ['默认数据1', '默认数据2']&#125;;export default (state = defaultState, action) =&gt; &#123; // state指的是上一次存储的数据, action是组件传过来的内容 return state;&#125; index.js123456789// 从redux引入createStore方法import &#123; createStore &#125; from 'redux'; // 从刚刚创建的reducer.js引入reducerimport reducer from './reducer';// 定义一个名为store的redux存储区，我们把reducer作为参数传入createStore方法来构造这个存储区，store里的数据只可以通过reducer来修改。const store = createStore(reducer);// 导出storeexport default store; 创建子组件List.js1234567891011121314151617import React from 'react';const List = (props) =&gt; &#123; return ( &lt;div&gt; &lt;ul&gt; &#123; props.list.map((item, index) =&gt; &#123; return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; );&#125;export default List; ❗️此处的List组件是一个无状态组件，没有任何的逻辑操作，所有逻辑操作交由父组件执行。 接着修改你的App.js (我这里把App.js作为父组件)1234567891011121314151617181920import React, &#123; Component &#125; from 'react'import store from './store'import List from './List'export default class App extends Component &#123; constructor(props) &#123; super(props); // 用store的getState()方法取出store的数据，再赋值给this.state this.state = store.getState(); &#125; render() &#123; return ( &lt;div&gt; &lt;input type="text"/&gt; &lt;button&gt;提交&lt;/button&gt; &lt;List list=&#123;this.state.list&#125;&gt;&lt;/List&gt; &lt;/div&gt; ) &#125;&#125; 此时运行出来应该是这样目录结构 修改store此刻我们已经可以取到store里的数据了，那么我们现在想在点击提交的时候，list里新增一条数据，并且实时地响应出来，应该怎么做呢。 修改App.js1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; Component &#125; from 'react'import store from './store';import List from './List'export default class App extends Component &#123; constructor(props) &#123; super(props); this.state = store.getState(); // 修改事件的this指向，否则this指向undefined this.handleInputChange = this.handleInputChange.bind(this); this.handleClick = this.handleClick.bind(this); &#125; render() &#123; return ( &lt;div&gt; &lt;input type="text" onChange=&#123;this.handleInputChange&#125; value=&#123;this.state.inputValue&#125; /&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;提交&lt;/button&gt; &lt;List list=&#123;this.state.list&#125;&gt;&lt;/List&gt; &lt;/div&gt; ) &#125; handleInputChange(e) &#123; // 1) 创建action const action = &#123; type: 'change_input_value', value: e.target.value &#125; // 2) 传给store store.dispatch(action); // 3) store如果接收到了action, 会自动把之前的数据和action传给reducer (这步store帮我们做了) &#125; handleClick() &#123; const action = &#123; type: 'add_todo_item', &#125; store.dispatch(action); &#125;&#125; 然后修改我们的reducer123456789101112131415161718192021const defaultState = &#123; inputValue: '', list: ['默认数据1', '默认数据2']&#125;;// 4) reducer拿到之前的数据和当前操作的信息后对数据进行处理，然后返回新的数据给storeexport default (state = defaultState, action) =&gt; &#123; const newState = JSON.parse(JSON.stringify(state)); //深拷贝，因为reducer可以接收state, 但绝不能修改state 所以要拷贝state switch (action.type) &#123; case 'change_input_value': newState.inputValue = action.value; return newState; //return给了store case 'add_todo_item': newState.list.push(newState.inputValue); // 添加成功后清空inputValue newState.inputValue = ''; return newState; default: break; &#125; return state;&#125; 此时我们会发现在input框里输入数据页面是没有反应的，点击提交，页面上也没有发生任何变化，别急，我们先来打印一下store，这也是我们学redux时经常容易犯的错误。 我们在handleClick方法的最后，用store.getState()方法来打印一下store的值❗️注意是最后，store.dispatch(action)的后面1console.log(store.getState()); 我们发现store里的数据已经被改变了，list增加了1条数据，inputValue也被清空了，这证明我们之前在reducer中编写的代码都生效了，但是都并没有渲染在页面上。现在页面上input的value值是空值，是因为一开始inputValue的值就是空，而不是我们后来清空的。这一切都因为我们并没有在组件中去监听更新store里的数据，我们应该在页面中监听store，当store发生变化时，实时更新我们的数据。 监听storeApp.js最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React, &#123; Component &#125; from 'react'import store from './store';import List from './List'export default class App extends Component &#123; constructor(props) &#123; super(props); this.state = store.getState(); this.handleInputChange = this.handleInputChange.bind(this); this.handleClick = this.handleClick.bind(this); // 5) 监听store的变化 // 订阅store, 只要store发生改变, subscribe里的函数就会被自动执行 this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); &#125; render() &#123; return ( &lt;div&gt; &lt;input type="text" onChange=&#123;this.handleInputChange&#125; value=&#123;this.state.inputValue&#125; /&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;提交&lt;/button&gt; &lt;List list=&#123;this.state.list&#125;&gt;&lt;/List&gt; &lt;/div&gt; ) &#125; handleInputChange(e) &#123; const action = &#123; type: 'change_input_value', value: e.target.value &#125; store.dispatch(action); &#125; handleClick() &#123; const action = &#123; type: 'add_todo_item', &#125; store.dispatch(action); &#125; handleStoreChange() &#123; // 6) 当感知到store变化的时候, 调用store.getState()方法从store中重新取一次数据, 然后调用setState替换掉当前组件中的数据, 这样就会同步数据了 this.setState(store.getState()); &#125;&#125; ❗️我们上面说过，不要直接更改state的值，所以我们每次修改时都创建了一个新的state，返回的也是全新的state。不过，大量重复的代码就是问题的源泉，我们在编写代码时，理应去减少出现bug的可能性。所以，当我们日常开发时，我推荐使用immutable.js或一些其他的第三方库——我们在最初就把state生成immutable对象, 这样可以百分百保证state不会被改变。 总结拿刚刚的例子来说，我们首先把input的值和store中的inputValue关联到了一起，如果你想修改input框的value值，就必须通过修改store中的inputValue实现。我们用onChange事件监听了input，在每次修改input中的值的时候，我们都创建了一个action，并把这个action派发给了store。 store接收到了这个action，会自动把这个action传给reducer。reducer拿到这个action，开始对比action的type值，并进行相应的数据操作，之后返回了一个新的数据给store。我们在组件内监听了store的变化，所以当reducer把值返回给了store，store更新了自己的数据，我们的组件就会监听到刚刚store的变化，随之更换组件内store的数据。 input输入流程：App→store→reducer→store→App检测到store发生变化，更新数据，渲染页面 点击提交流程：App→store→reducer→store→App.js检测到store发生变化，更新数据→父组件App重新渲染触发子组件List更新渲染 优化写到这里，如果你只想了解该怎么使用redux，那么至此之前的代码应该已经足够让你上手去使用redux了。但是其实上面的代码中还有很多可以优化的地方，我没有直接把优化过后的代码写出来是怕不易于初学者阅读学习，容易看晕。 比如说我们应该利用actionTypes统一常量, 预防因拼写引发的bug，以及将action的创建放到actionCreators中统一进行管理。这样做的优点除了提高代码的可维护性，还可以方便自动化测试。 在实际开发中，redux也应遵照组件化开发，建议每个组件都应该拥有自己的store文件夹，src目录下的store应仅仅作为各个组件内store的集合。 在子组件List上，我们使用数组的index作为key值并不是一个好的做法。事实上我认为不到万不得已的情况不要使用index作为key值。因为列表每一项的顺序都可能会发生变化（比如说我们如果删除list中的某一项时，list的顺序就发生了变化，list中每一项的index值都发生了改变），react又是通过diff算法去渲染页面的，diff算法通过key值去对比虚拟dom，如果key值全部发生改变，那虚拟dom便会全部更新，这明显会降低我们的性能，所以说使用数组的index作为key值是下下策，有兴趣的话可以去看看这篇文章深度解析使用索引作为 key 的负面影响。 因为diff算法（虚拟dom从顶层 层层比对）的原因，所以在父组件内只要一改变inputValue的值，子组件就会重新渲染，即使我们并没有修改list数据。这同样会降低我们的性能，试想一下，如果你拥有非常多的子组件，父组件输入任何一个字符都会导致所有子组件的重新渲染，这会消耗多少的性能呢？为了解决这种多余性能的消耗，我们应该在子组件内利用react内置的生命周期函数shouldComponentUpdate去阻止子组件跟随父组件去执行无谓的render函数，这样就可以避免虚拟dom的比对，提升性能。 推荐阅读1、yarn构建react项目2、带你上手react-redux+代码示例 这篇文章到这里就全部结束了，本来想在一篇里把redux和react-redux都写出来，但是怕太长了，所以下次找时间再写react-redux吧。 如果你对这篇文章有任何疑问或补充，都可以在评论区给我留言讨论。 顺便一提最近看了排球少年的动漫，虽然比较冷门但是真的是一部不可多得的好作品，无论你喜不喜欢排球我觉得你看了这部动漫后都会爱上它的，强烈安利一波。 大家晚安啦。]]></content>
      <tags>
        <tag>categories</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常规操作【初始化/提交代码/撤销/删除/合并分支/储存变更】]]></title>
    <url>%2F2019%2F02%2F18%2FgitOrder%2F</url>
    <content type="text"><![CDATA[由于公司一直用的SVN对项目进行版本管理，所以一直也没怎么接触过git。虽然我之前有使用码云私有仓库管理代码，但是我对git的操作还停留在git add . git commit -m上。直到最近听说github的私有仓库免费了，所以我又抽时间看了下git的基本操作(免费使我进步，哈哈哈~~)，下面是我整理的笔记，希望对你有帮助。 基础部分初始化gitgit init 初始化 检查状态git status 检测文件状态(有没有被追踪Untracked) 提交到版本库的文件不会显示在git status里 GIT四种状态untracked 未被追踪modified 表示工作区修改了某个文件但是没有添加到暂存区staged 表示把工作区修改的文件添加到了暂存区但是没有比较到版本库Commited 表示数据被安全的存储在本地库中 GIT三层结构working directory 工作区staging index 暂存区git directory(Repository) 版本库 提交代码git add fileName 追踪 (从工作区添加到暂存区)git add . 追踪全部本地文件到暂存区git commit -m ‘描述’ 提交到版本库 告诉git使用者的身份git config —global user.name yourNamegit config —global user.email yourEmail 其他git config —list 查看git配置情况git log 查看提交信息(提交人/邮箱)git help 命令名 (例git help add):将弹出想要查找的命令的文档 撤销部分git add . + git commit -m ‘msg == git commit -am ‘msg’ 例如: git commit -m ‘versions 1.0’ 提交到版本库这时候不能使用 ‘versions 1.0’ 再次提交了 如果还想用这个名字的话 使用↓↓git commit—amend 撤销上一次的提交,并将暂存区的文件重新提交 也可以通过这个命令改变版本描述(不改变暂存区内容的情况下) git checkout — fileName 编辑器的文件恢复成了修改前的样子(最后一次提交)git checkout — . 撤销恢复全部文件 git reset HEAD fileName 撤销提交到暂存区 （这的HEAD为头指针）此处HEAD也可以换为版本号(将相应版本里的文件拉回到暂存区)这一步不会影响工作区↑↑,想工作区恢复 需要使用git checkout — fileNameUnstaged changes after reset(将改变撤销暂存); 可以通过git log 查看各种版本的版本号 然后通过版本号恢复到某个版本(这也会改变HEAD的指向)git reset 版本号(commit后面的) 文件名;再用git checkout — fileName 拉回来 删除部分git rm fileName:此步操作会把工作区的文件连同暂存区的文件一起被删除 当工作区的文件或者暂存区的文件被修改后,想进行git rm 操作,git会禁止我们删除,起到了一个防止误删除的作用。如果想要保留工作区的文件 那么就要用git rm —cached 文件名 来仅仅删除暂存区的文件git rm — cached fileName 在不小心将不需要追踪的文件添加到暂存区后,想删除暂存区的文件但是不想删除工作区的文件很有用git rm -f fileName 同时删除工作区和暂存区的文件mv fileName newFileName 本地(工作区)重命名mv fileName newFileName 工作区和暂存区都重命名 git指针概念Git指针当提交一个版本的时候,就会有一个版本号(V1),这时候有两个指针指向这个版本,一个是master(当前分支指针),一个是HEAD(指向当前分支的最后一个版本)当提交了一个新的版本(V2),master指针和HEAD指针都指向了最新一次的提交(V2),V2有一个指针指向V1。这的指针是指（文件中有一块地方保存着其他文件的地址），调用V2的时候可以直接通过V2找到V1的地址，从而调用V1，以达到方便的访问V1的目的，以此类推。如果在V2版本上创建了一个分支（D1）的时候，master分支指针依旧会指向V2，新的D1分支指针会指向新的D1分支,当切换到D1分支的时候,head指针会切换到D1上,此时的D1还有一个指针指向V2。修改D1分支的时候,D1和head指针也会以此类推到D2。当从D2合并分支到V2的时候，会形成V3分支，V3分支既指向V2分支，又指向D2分支。此时HEAD和master指针指向V3分支。 分支部分git branch 查看本地分支git branch -a 查看远程分支git branch branchName 创建新分支git checkout branchName 切换分支git branch -d branchName 删除分支 (此操作必须保证当前的分支非想要删除的那个分支)git branch -m branchName newBranchName 修改分支名git checkout -b branchName 创建分支并切换分支 合并分支首先切换到主分支（master）git merge branchName 合并分支这时候如果branch和master在相同位置有不同的修改,也就是发现了冲突的时候,git会抛出一个让我们来手动解决冲突的错误↓↓。automatic merge failed:fix conflicts and then commit result.(自动合并失败:修复冲突，然后提交结果。)&lt;&lt;&gt;&gt;branchName 是branchName分支的内容然后重新git commit -am ‘msg’ 提交到暂存区及版本库; git diff 比较差异(默认比较工作区和暂存区文件的差异) 如果没有差异是不会有任何展示的git diff —staged 比较暂存区与版本库之间的差异git diff 还可以比较同一个分支中两个不同的版本之间的差异(在版本回退时非常有用)版本hash值 最少选择4个 git默认选择7个 建议尽量选择8-10个 这样才能保证唯一性git diff branchName 还可以比较两个分支之间的差异 储存变更部分比如在branch分支上进行修改后,切换到master分支,会报一个please commit your changes or stash them before you switch branches;(请在切换分支之前提交更改或将其隐藏)的错误,我们使用git stash 暂存工作区的修改,然后git会帮我们自动切换到修改前的状态这时切换分支就不会报错了,因为git在进行分支切换的时候,主要改变的是版本库,当工作区有改变的时候,会直接将工作区的改变覆盖到另外一个分支上,从而影响另外一个分支。如果我们使用git stash进行封存,git就会自动将工作区的改变撤销掉,回到修改前的状态(上一次提交后的状态)。git stash list 查看当前保存了哪些本地文件git stash apply stash@{0} 返回之前用git stash封存的改变stash@{0} 里面的0根据提交git stash的次数以此类推git stash pop stash@{0} 拉回到暂存区和本地此时再执行 git stash list 查看封存的文件时 stash@{0}不见了也就是说 git stash pop stash@{0} 是在git stash apply stash@{0}的基础上,增加了一个删除命令。也就是说，返回的同时，删除git stash中的这个文件的命令。git stash drop stash@{0} 删除封存的修改。综上 git stash pop stash@{0} = git stash apply stash@{0} + git stash drop stash@{0} 使用远程仓库管理代码(github/码云)git push 远程仓库地址 (分支:可不填) :推送到远程仓库git pull如果使用ssh地址在管理员账户使用 ssh-keygen 生成密钥 文档后缀为File的为私钥 后缀为PUB(public的缩写) File为公钥然后点击github→setting→SSH→New SSH key→输入标题/添加公钥;此时就可以用SSH地址拉取了 推代码到远程仓库:方法1: git push git@github.com:仓库名称(name/xxx.com.git); 方法2: git push 仓库地址(https://github.com/name/xxx.com.git) 方法3: git remote add 取一个仓库名(通常使用origin) git@github.com:仓库名称(name/xxx.com.git); git remote -v 查看添加的远程仓库然后使用 git push origin master 推送到远程仓库 git pull 仓库名 分支名(master) 拉取到本地 让git不追踪指定文件如果有一些文件不想让git对它追踪touch .gitignore : 在项目目录下建立一个 .gitignore文件vim .gitignore 编辑这个文件然后把想忽略的文件添加到cmd命令行或者可以 index.* :忽略所有以index.为开头的文件(支持glob规则)也可以在里面加上.gitignore 让他忽略.gitignore文件glob规则: (&#42;号)匹配零或多个任意字符 [abc]匹配任何一个列在方括号中的字符 (?号)只匹配一个任意字符 [0-9]/[a-z]匹配范围 已经长传到暂存区/版本库的想忽略的文件,可以:git rm index.html —cached 删除暂存区的文件任何再提交 git commit -m ‘msg 提交↑的操作:这时,提交的还是暂存区的文件,本地仍然是改变这个index.html,这个改变并没有提交到暂存区,更没有到版本库只有将暂存区里相应文件删除后,忽略才生效 ~]]></content>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「N1语法」かたがた、かたわら、がてら的区别]]></title>
    <url>%2F2018%2F12%2F28%2FN1-ktwr-ktgt-gtr%2F</url>
    <content type="text"><![CDATA[前言从今天开始，我会陆续整理N1与N2易混淆的语法，以便日常复习记忆。说到易混淆的语法，我第一个想到的就是N1语法的「かたがた、かたわら、がてら」这三大壮汉。不夸张的说，有些已经通过N1的小伙伴可能都不太能分清这三者，好了，废话不多说，先来看一下它们三者的接续方法。 接续方法 かたがた かたわら がてら 名词（サ变词干） 名词+の 名词（サ变词干） 动词原形 动词ます形 用法及造句1、A かたがた B日文解释：AのついでにBをする。AをかねてBをする。 1、书面用语2、趁着做A的机会顺便做B，多用于信件和正式场合。例：「お礼を言う、お見舞い、ご報告、ご挨拶」等。造句：先日のお礼かたがた、お見舞いに行く。 2、A かたわら B日文解释：Aと同時に/の合間にbをする。 1、一边做A的同时，顺便做B，A为本质。2、必须是长期的事。造句：彼は勉強のかたわら、アルバイトをしている。 3、A がてら B日文解释：Aしながら/のついでにBをする。 1、与かたがた相似，较口语2、趁着做A顺便做B（A、B有主次顺序，是短期的事）。造句：夕涼みがてら、蛍を見に行った。 日本人眼中的语法说起来挺有趣的，之前碰巧给一个日本的朋友看过这三个语法，他却和我说从来没看到过かたがた这个用法，甚至连它的意思都不是很清楚。 从聊天截图可以看出，日常中他们连かたわら和がてら也不怎么用，但是我也听过其他的日本朋友说过御礼方々「おれいかたがた」这种用法。所以到底要在什么时候使用这三个语法，还是根据实际情况自己考量吧。 以上です。]]></content>
      <tags>
        <tag>notes</tag>
        <tag>N1</tag>
        <tag>日语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊深拷贝、浅拷贝的区别【Vuex踩坑记录】]]></title>
    <url>%2F2018%2F12%2F24%2FdepthClone%2F</url>
    <content type="text"><![CDATA[vuex踩坑记录前一阵子在使用Vuex的时候，有这样一个报错。 Do not mutate vuex store state outside mutation handlers. 直译过来就是不要在突变处理程序之外改变vuex存储状态。 我们都知道，既然使用了vuex，那么想要更改vuex中store的状态的唯一方法就是提交mutation，因为vuex不允许直接修改store的内容，所以才会报这个错误。我在已知这点的情况下，先slice()了vuex里的数据，再进行使用，可还是报了相同的错误。后来查了下资料，才发现是深浅拷贝的问题，下面就来浅谈一下深浅拷贝的区别，以及总结几种不同的深浅拷贝方法。 深浅拷贝介绍在很多编程语言中（例如Java、JavaScript、C++），不同的数据类型，对应着不同的内存存储方式，基本数据类型通常保存在栈内存中，而引用类型仅仅是在栈内存中保存了一个指向堆内存的地址，通过在栈内存中保存的地址，去访问到保存在堆内存中的值。我们所说的浅拷贝，正是拷贝了栈内存中的引用类型数据的指针，而深拷贝，则是在拷贝数据内容的同时，生成新的指针，在堆内存中开辟自己的空间。我用大白话来解释一下，所谓的浅拷贝，比方说我们有b这样一个对象，我们用a复制了b，当我们改变b的时候观察a会不会随之变化，如果a也变了，那就是浅拷贝（因为只复制了栈内存中的指针，它们指向的还是相同的堆内存空间），如果a没变，那证明a和b在堆内存中分别占用了不同的空间，也就是深拷贝了。 浅拷贝1234//我在此处定义了一个变量aVuexData，aVuexData是一个包含三个对象的数组。let aVuexData=[&#123;name:'Jack',age:18&#125;,&#123;name:'Tom',age:20&#125;,&#123;name:'David',age:15&#125;];let arr=aVuexData;console.log(arr==aVuexData);//true,证明arr与aVuexData的指针相同，它们指向堆内存中相同的数据。 紧接着我们修改arr。12arr[0].name='Hank';console.log(aVuexData[0].name=='Hank');//true aVuexData[0].name==’Hank’为true，证明aVuexData[0]的name值由原先的Jack变成了Hank，但我们没有对aVuexData做任何操作，aVuexData是随着arr改变而改变了，这是显而易见的浅拷贝。 slice()拷贝我们知道slice()方法可从已有的数组中返回选定的元素，它的返回值是一个新的数组。这样看来，slice()似乎可以帮我们达到深拷贝的目的，但它并不可靠，这也正是我在vuex里报错的原因，下面来看一个例子。接着使用上面的aVuexData。123let arrNew=aVuexData.slice();console.log(arrNew==aVuexData);//false，也就是说，此处的arrNew与aVuexData指向了不同的指针地址，即使数据相同，它们也各自在堆内存中拥有着自己的一席之地。console.log(arrNew[0]==aVuexData[0]);//true 注意，这时候打印arrNew[0]与aVuexData[0]是否相等，返回的结果是true，证明它们的指针还是指向同一个堆内存地址，也就是说，我们虽然深拷贝了外层的数组，但并没有对数组中的引用类型数据进行深拷贝——它依旧是仅仅拷贝了指针地址，依旧是一个浅拷贝。slice()并没有让内层的引用类型数据开辟新的堆内存空间，这也正是vuex报错的原因，我们在改变内层数据的时候，其实还是直接修改了在vuex的store里的数据，所以才会报错。 concat()拷贝1let arrNew = [].concat(aVuexData); concat()方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。在拷贝引用类型的数据时，concat()方法的效果与slice()方法完全相同。slice()与concat()都可以进行引用类型内数据为基本类型数据的深拷贝，但我认为这样做太过冒险，因为一旦内容里被加上了一个引用类型的值，那么它就不再是一个深拷贝了，所以为了以防万一，我还是把这两个方法归在了浅拷贝里。 深拷贝那么，究竟怎样才能万无一失的进行深拷贝呢？ 递归方法我这边自己封装了一个函数1234567891011121314151617181920212223242526let DeepClone = (value) =&gt; &#123; let type = typeof value; //因为数组要用到push 对象要用Object.keys 所以得是不用的类型 这里先定义undefined 在后面定义类型 let newone = undefined; if (type === 'string' || type === 'number' || type === 'boolean') &#123; //基础类型 newone = value; //基础类型直接等于就好了 &#125; else if (type === 'object') &#123; //堆类型 if (value === null) &#123; newone = null; &#125; else if (Object.prototype.toString.call(value).slice(8, -1) === 'Object') &#123; //对象要先将newone改为对象类型 newone = &#123;&#125;; for (let key of Object.keys(value)) &#123; newone[key] = DeepClone(value[key]); //递归直到值为基本类型 &#125; &#125; else if (Object.prototype.toString.call(value).slice(8, -1) === 'Array') &#123; newone = []; //对象要先将newone改为数组类型 for (let i = 0; i &lt; value.length; i++) &#123; newone.push(DeepClone(value[i])) //与对象同理 &#125; //不用foreach是如果有undefined会有bug &#125; &#125; return newone &#125; //测试 let arrDeepClone = DeepClone(aVuexData); console.log(arrDeepClone[0]==aVuexData[0]);//false 此时，它们的内层数据也已经开辟了新的堆内存空间，是一个完完全全的深拷贝了。 利用JSON对象的stringify和parseJSON.stringify()方法用于将 JavaScript 值转换为 JSON 字符串。JSON.parse()方法用于将一个 JSON 字符串转换为对象。12345let jsonDeepClone = (value) =&gt; &#123; return JSON.parse(JSON.stringify(value));&#125;let arrJsonDeepClone = jsonDeepClone(aVuexData);console.log(arrJsonDeepClone[0] == aVuexData[0]); //false，同样实现了深拷贝 所有的打印结果一览 闲聊终于赶在圣诞节前把这篇文章整理出来了，非常的开心 ~ 因为最近刚刚把博客搭出来，还处在一个总结整理的阶段，所以每写一篇新的文章，感觉都是对过去自己的肯定，也希望我过去这一段时间的踩坑经验可以帮助到更多人解决工作与学习上的问题。如果你觉得我的文章对你有帮助，请点个赞鼓励一下我，这样我会加大马力继续努力多出些干货的，嘻嘻。如果你对本文有任何的疑问或补充，都欢迎在评论区给我留言讨论，最后祝大家平安夜、圣诞节快乐，记得吃苹果哦 ~🍎🍎感谢观看。 2020年4月7日更新利用JSON对象的stringify和parse方法也不是万无一失的。 会忽略 undefined会忽略 symbol不能序列化函数 12345678const obj = &#123; a: undefined, b: 'hi', c: function() &#123;&#125;, d: Symbol('syl'),&#125;jsonDeepClone(obj)// &#123;b: "hi"&#125; 不能解决循环引用的对象 123456789let circularObj = &#123; a: '', b: &#123; c: '', &#125;,&#125;circularObj.a = circularObj.b;circularObj.b.c = circularObj.a;jsonDeepClone(circularObj); 循环引用会报错。 MessageChannel如果你想拷贝的对象含有undefined或循环引用，但是不包括函数和Symbol对象，那么就可以使用MessageChannel()来进行深拷贝。 MessageChannel()方法创建了一个消息通道，并通过它的两个MessagePort属性发送数据。并且MessageChannel()方法存在两个属性（port1、port2），分别代表两个通道端口，这两个通道都可以通过postMessage()向对方发送数据。 来看一个小例子。123456789101112const channel = new MessageChannel();const &#123; port1, port2 &#125; = channel;port1.onmessage = function (msg) &#123; console.log(msg) console.log(`port1接收了：$&#123;msg.data&#125;`)&#125;port2.onmessage = function (msg) &#123; console.log(`port2接收了：$&#123;msg.data&#125;`)&#125;// 发送消息port1.postMessage('port1发送的消息')port2.postMessage('port2发送的消息') port2接收了：port1发送的消息port1接收了：port2发送的消息 这时候你可能会疑惑，MessageChannel与深拷贝有什么关系呢，其实，postMessage里传递的数据，实际上是经过深拷贝的，它不同于Json对象，对undefined和循环引用都是友好的。 1234567891011121314151617181920212223242526272829function structuralClone(obj) &#123; return new Promise(resolve =&gt; &#123; const &#123; port1, port2 &#125; = new MessageChannel(); port2.onmessage = ev =&gt; resolve(ev.data); port1.postMessage(obj); &#125;)&#125;// 循环引用structuralClone(circularObj).then((deep) =&gt; &#123; // 不要忘记MessageChannel是异步的 let copyObj = deep; console.log(copyObj, circularObj); console.log(copyObj == circularObj); // false&#125;);// undefined与内置对象，使用刚刚的例子const obj = &#123; a: undefined, b: 'hi', c: function() &#123;&#125;, d: Symbol('syl'), e: &#123; f: 'wow' &#125;,&#125;structuralClone(obj).then((deep) =&gt; &#123; let copyObj = deep; console.log(copyObj, obj); console.log(copyObj == obj); // false&#125;); 来看一下执行结果。 报错了，上面提过，这种深拷贝方式不适合包含函数的对象和Symbol()。 我们去掉它们试一下。12345678910111213const obj = &#123; a: undefined, b: 'hi', c: &#123; d: 'wow' &#125;,&#125;structuralClone(obj).then((deep) =&gt; &#123; let copyObj = deep; console.log(copyObj, obj); console.log(copyObj == obj); // false console.log(copyObj.c == obj.c); // false 内置对象同样被拷贝了&#125;); 当然，最保险的还是使用lodash的深拷贝(cloneDeep)，有兴趣的可以去看看。]]></content>
      <tags>
        <tag>categories</tag>
        <tag>vue</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用网易云生成你自己的音乐外链、提取lrc歌词文件、专辑图片。]]></title>
    <url>%2F2018%2F12%2F12%2FmusicLinks%2F</url>
    <content type="text"><![CDATA[在使用各种HTML5音乐播放器的时候，我们通常需要借助一些音乐网站寻找音乐外链，或者是自己用云服务器生成音乐外链，但是音乐外链网站的歌曲数量实在有限，自己生成又浪费时间成本。前一阵子我在搭建博客的时候，使用的是aplayer播放器，顺便自己研究了下怎么用网易云生成音乐外链，非常实用且便捷快速。本篇文章就来总结一下如何使用网易云音乐网站生成你自己的音乐外链、提取专辑图片以及lrc歌词文件。有关于aplayer的使用，我在之后会单独写一篇文章来讲。我在写这篇文章的时候，避免使用了一些专有词汇，无论你会不会使用开发者工具，都可以轻便的上手，当然开发大佬请无视。 提取音乐外链首先，打开网易云音乐的官网，搜索你想要的音乐。 踩坑记录在说正确提取外链方式之前，我先来介绍一下我当时踩的坑，真是一把血泪，如果对这部分没兴趣的朋友可以直接跳到生成外链部分。当时我获取音乐外链的方式是在音乐界面点击左侧的“生成外链播放器”，如下图所示。然后在点开的页面里单击鼠标右键打开检查，然后在最上面一栏寻找Network，找到它下面的Media（如果是空的则重新刷新页面），右键点击下面的Copy，选择Copy link address，这样我就得到了这首歌的音乐外链，不过，在后续使用过程中我发现，这样获取的音乐外链会在一段时间后失效，导致我网页的歌时好时坏，最初我还怀疑自己复制错了值，在我重复测试几次之后，证明这样获取的外链确实会不定期刷新。所以即便这种方式方便快捷，可它却并不可靠。当时使用的方法如下↓。不过好在，我之后找到了更简易的办法，就是直接复制网站的网址。 生成外链首先，我们先来复制一下歌曲的网址。然后，重点来了！ 音乐网址：https://music.163.com/#/song?id=557583012 修改后的网址：https://music.163.com/song/media/outer/url?id=557583012.mp3 修改后的网址也就是你所需要的音乐外链，过程就是删除前面的#号，在song后面加上/media/outer/url，最后在结尾处加上.mp3就大功告成啦，没错，就是这么简单，你就拥有了不需要任何云服务器的音乐外链。顺便在这里强推一下断眉的这首Patient，实在是太好听了！PS:这样做可以把网易云不允许你生成音乐外链的版权音乐的音乐外链生成出来，不过我并不推荐你这么做，因为我觉得版权意识还是需要靠大家一起普及开来，所以希望大家在做音乐外链的时候尽量选用那些可以生成外链的音乐。例如上面这首Patient就是一首版权音乐，我在这里只是演示一下生产外链的方法，虽然我很想把这首歌放到博客里给你们听，但是为了版权，还是建议大家自己去网易云音乐听吧 ~ 提取lrc歌词文件首先，还是在网易云音乐的官网搜索你想要的音乐，然后点开Network，此时注意下面一行的选项必须在All上，如果刚刚选择了Media要记得切换回来，然后在搜索框输入lyric（如果没有展示F5刷新页面），把显示出的那个文件右键copy→copy response，如下图。下一步从最上方的Network切换到Console。 然后输入a=在此处粘贴你刚刚复制的内容，并回车，展示如下图。 紧接着输入a.lrc.lyric，回车，下面就是你要提取的lrc歌词文件啦。 如果输入a.tlyric.lyric，那么就是歌词的翻译版本。 提取专辑图片还是点开Network，选取下面一行的img，Copy➡️Copy link address获取图片外链，或者你也可以双击图片，使浏览器在新的网页中展示这张图片，此时我们就可以右键保存它，位置如下↓。 到此，你已经拥有了lrc歌词文件、专辑封面、以及最重要的音乐外链，你可以随意去生成你喜欢的歌单了，如果对以上的内容有任何疑问或补充，欢迎在评论区留言给我。感谢观看。鞠躬 ~]]></content>
      <tags>
        <tag>categories</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue+vue-i18n搭建国际化网站【兼容Element-UI、动态切换css】]]></title>
    <url>%2F2018%2F12%2F08%2FvueI18n%2F</url>
    <content type="text"><![CDATA[最近因为雾霾很厉害，所以发烧了在家养病，想着难得有空，正好趁机整理一下以前在项目中遇到过的问题及需求。今天想来写一下之前为项目搭建的国际化（i18n）功能，由于之前项目主要是使用的Vue+Element-UI，所以本文章中分别有vue-i18n和兼容element-ui的vue-i18n两种写法，大家可以按需参考。 前言本文是基于vue进行实现的国际化功能，我假设你对vue已经有了一定的了解，并且已经拥有了属于你自己的vue项目环境，这里不做过多阐述，如果对这一步有疑问的话，请参考我的另一篇文章，进行项目搭建。如果你只是急需一个已经搭建好的i18n模版，也可以直接去我的github仓库下载我已经写好的项目模版。 vue-i18n安装vue-i18n1npm install vue-i18n 配置文件如下图创建i18n文件夹，在i18n文件夹里分别创建i18n.js、langs文件夹，在langs文件夹下面创建你的语言文件（cn.js/en.js/ja.js）和index.js文件。语言包分别为中文/英文/日语，大家在项目中选择创建自己需要的语言包即可。 i18n.js1234567891011import Vue from 'vue'import VueI18n from 'vue-i18n'import messages from './langs'Vue.use(VueI18n)//从localStorage中拿到用户的语言选择，如果没有，那默认中文。const i18n = new VueI18n(&#123; locale: localStorage.lang || 'cn', messages,&#125;)export default i18n index.js12345678import en from './en'import cn from './cn'import ja from './ja'export default &#123; en, cn, ja,&#125; cn.js1234567const cn = &#123; message: &#123; 'hello': '你好', &#125;&#125;export default cn en.js1234567const en = &#123; message: &#123; 'hello': 'hello', &#125;&#125;export default en ja.js1234567const ja = &#123; message: &#123; 'hello': 'こんにちは', &#125;&#125;export default ja 🌟 在配置语言包的时候，key值一定要保持统一，因为i18n是通过你的key值来切换语言的，如果key值有误，就不能正确的切换语言包，这一点千万要注意。 main.js12345678import i18n from './i18n/i18n'new Vue(&#123; el: '#app', i18n, //加上i18n components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 到此我们的i18n已经全部配置结束了，下面我们去页面中进行使用。 配置页面HTML部分1234&lt;p&gt;&#123;&#123;$t(‘message.hello’)&#125;&#125;&lt;/p&gt;//此时应该是中文&lt;button @click="switchLang('en')"&gt;英语&lt;/button&gt;&lt;button @click="switchLang('cn')"&gt;中文&lt;/button&gt;&lt;button @click="switchLang('ja')"&gt;日语&lt;/button&gt; Js部分1234567methods:&#123; switchLang(lang) &#123; this.$i18n.locale = lang //把语言保存在localStorage中 localStorage.setItem('lang',lang); &#125; &#125;, 到此，运行npm run dev就可以看到可以进行语言切换的项目了。 根据语言切换css到此，我们已经实现了基本的国际化功能。但是，我们在切换语言的时候不得不面临的一个问题就是因为语言的不同，即使是同一句话，文字样式的长度也会不同。所以这时候特别容易产生一些页面样式上的结构错位，为此我们就需要根据不同语言来切换项目的css。我这边提供的思路是在最上层html的div上添加一个可以动态切换class的变量，以改变项目的父级的class名称，实现切换语言的同时切换css样式。 HTML部分1234&lt;template&gt; &lt;div :class="langCss"&gt; &lt;/div&gt;&lt;/template&gt; Js部分在data中定义保存class的变量123456data () &#123; return &#123; langCss:window.localStorage.getItem('lang')||'cn', //先去取localStorage里保存的语言，如果没有，那么就默认中文 //这么做的意义是为了用户在刷新页面的时候样式不丢失。 &#125; 紧接着在我们的switchlLang函数后添加新的一行，以便在切换语言的同时切换class。12345switchLang(lang) &#123; this.$i18n.locale = lang localStorage.setItem('lang',lang); this.langCss=lang;//新添加的，以便切换父级class &#125; Css部分在style标签中中设置你想要的样式，我这边以改变文字颜色为例。123456789.en button &#123; color: steelblue;&#125;.cn button &#123; color: #666;&#125;.ja button &#123; color: seagreen;&#125; 到此vue-i18n的内容就全部结束了，由于现在很多人在使用vue的同时会搭配Element-UI使用，所以我们在现在的基础上优化一下我们的项目，以便可以兼容Element-UI。 兼容Element-UI的i18n参考网址Element组件文档Element官网-i18n 安装Element相关依赖npm i element-ui -s 修改配置main.js123456789101112//引入element-uiimport ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';Vue.use(ElementUI);new Vue(&#123; store:store, i18n, ElementUI,//添加element-ui el: '#app', components: &#123; App &#125;, template: '&lt;App/&gt;',&#125;) i18n.js1234567891011121314import Vue from 'vue';import locale from 'element-ui/lib/locale';import VueI18n from 'vue-i18n';import messages from './langs';Vue.use(VueI18n);//从localStorage中拿到用户的语言选择，如果没有，那默认中文。const i18n = new VueI18n(&#123; locale: localStorage.lang || 'cn', messages,&#125;)locale.i18n((key, value) =&gt; i18n.t(key, value)) //为了实现element插件的多语言切换export default i18n 修改语言包123456789101112131415161718192021222324252627282930313233343536// en.jsimport enLocale from 'element-ui/lib/locale/lang/en'const en = &#123; message: &#123; 'hello': 'hello', &#125;, ...enLocale&#125;export default en;// **********分割线**********// cn.jsimport zhLocale from 'element-ui/lib/locale/lang/zh-CN'const cn = &#123; message: &#123; hello: '你好，世界', &#125;, ...zhLocale&#125;export default cn;// **********分割线**********// ja.jsimport jaLocale from 'element-ui/lib/locale/lang/ja'const ja = &#123; message: &#123; hello: 'こんにちは、世界', &#125;, ...jaLocale&#125;export default ja; 如果console里有如⬇️警告，证明的你语言包没有配置正确，返回上一步修改语言包查看。 配置页面引用组件至此，我们就可以引入一个Element-UI的组件进行开发了，这里以dialog组件为例演示一下基于Element-UI的文字国际化方案。当然，你也可以去Element组件文档去引用一些别的组件，这全看你自己的项目需要。 我引用的是第一个dialog组件【基本用法】，引用成功后，页面如下图，这里不对组件引用做过多阐述。此时切换语言后，我们发现暴露在外层我们可修改的语言文字并不会有变化，但是你点击右上角的关闭符号后，会发现里面内置的语言已经改变了。 Js调用下面需要我们来手动配置一下未切换文字的语言包，配置方法同上文的配置页面，这里我顺便说一下，在js里调用国际化直接用this.$t(‘message.xxx’)即可，如下。1234567handleClose(done) &#123; this.$confirm(this.$t('message.confirm'))//js内部切换 .then(_ =&gt; &#123; done(); &#125;) .catch(_ =&gt; &#123;&#125;); &#125; github地址到此，国际化内容全部结束，我把所有代码都放到了我的github仓库上，里面提供了vue-i18n以及兼容Element-UI的两种国际化版本。假如上文中还有哪里不明白的，可以直接下载下来参考。如果有任何疑问或补充，欢迎在评论区给我留言讨论。感谢观看鞠躬 ～]]></content>
      <tags>
        <tag>categories</tag>
        <tag>vue</tag>
        <tag>i18n</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vue-cli从0搭建Vue开发环境]]></title>
    <url>%2F2018%2F12%2F08%2FBuildProjectsVue%2F</url>
    <content type="text"><![CDATA[在程序开发中，有三种方式可以创建vue项目，分别是本地引用、使用CDN引入vue.js、使用vue-cli搭建项目。本文主要介绍使用vue-cli搭建项目。 准备工作安装node请确保你的电脑上安装了node.js，以便于用npm包管理安装环境。如果还没有安装，请去node官网下载安装。 如果安装完成,打开你的终端（Windows-&gt;运行-&gt;cmd、macOS-&gt;command+space-&gt;输入“终端”），使用1node -v 检查你的node版本，出现版本号为已安装，如下图。 全局安装vue-cli1npm install -g vue-cli 如果报错证明你没有安装的权限，执行1sudo npm install -g vue-cli 然后输入你的管理员密码，安装成功。 搭建项目1vue init webpack project-name（你的项目名） 配置说明123456789Project name 项目名称Project description 项目描述Author 作者Vue build 打包方式（可直接回车）Install vue-router? 是否需要安装router，选y（一般项目中肯定会用到）。Use ESLint to lint your code? 是否需要js语法检测（可直接回车）Set up unit tests 是否安装单元测试工具（可直接回车）Setup e2e tests with Nightwatch? 是否需要端到端测试工具（可直接回车）Should we run `npm install` for you after the project has been created? 是否在项目执行完成后为您运行npm install（安装依赖，选y，当然你也可以后续自己手动安装依赖⬇️） 手动安装依赖12cd 你的vue项目npm run install 运行项目1npm run dev 出现️⬇️表示已运行成功，可以通过http://localhost:8080查看你的项目了。12DONE Compiled successfully in 2511ms 01:20:53I Your application is running here: http://localhost:8080 示例效果]]></content>
      <tags>
        <tag>categories</tag>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
