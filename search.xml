<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[yarn构建react项目]]></title>
    <url>%2F2019%2F05%2F15%2FbuildReact%2F</url>
    <content type="text"><![CDATA[前言我个人比较喜好用yarn开发，速度比较快，并且还有许多优势，这边不做过多介绍。你如果习惯直接使用npm，可跳过这步，直接去安装react官方脚手架Create-react-app。 搭建react开发环境安装yarn1npm install -g yarn 安装react官方脚手架Create-react-app npm直接安装 yarn安装 npm install -g create-react-app npm install create-react-app yarn -g 创建一个叫new-project的项目1create-react-app new-project ❗️注意项目名不可包含大写字母 运行项目 npm运行 yarn运行 npm start yarn start 运行后如下图。]]></content>
      <tags>
        <tag>categories</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步步带你入门Redux管理数据]]></title>
    <url>%2F2019%2F05%2F15%2Freact-redux%2F</url>
    <content type="text"><![CDATA[一些闲话&nbsp;最近忙里偷闲学习了react。由于之前一直都是使用vue做项目，所以学习react的时候觉得既熟悉又陌生。&nbsp;熟悉是因为它和vue拥有许多相似的概念，包括都推崇组件化、都拥有’props’的概念、核心都是视图层框架等等。虽然react不像vue拥有那么多丰富的API，但是在我看来，正因为react本身没有过度的封装，再加上react的社区非常成熟与活跃，才使得react的开发灵活多变，相比起来，我觉得react更适合大型项目的开发，react的函数式变成也更容易实现前端自动化测试。&nbsp;尤大自己也说过vue从一开始的定位就是尽可能的降低前端开发的门槛，让更多的人能够更快地上手开发。所以学习起来，vue更加圆滑，而react相对陡峭。两者在我看来都是非常优秀的框架，没有高低之分，我们可以根据不同的开发情况选择不同的开发工具。 前言今天主要是想写一下如何在react中管理数据。我会从搭建react项目开始，循序渐进，如果你对这其中的某些过程已经非常了解，可以在右侧的目录中跳过该章节。&nbsp;在此之前，如果你还不了解该如何搭建react项目，请参考我的另一篇文章「yarn构建react项目」。 ReduxRedux=Reducer+Flux，Flux是Facebook推出的最原始的辅助React的数据层框架，但是它并不是那么的好用，所以有人把Flux做了一个升级，变成了Redux。 为什么要使用redux请看下面这张图 假设底部绿色的组件要和最顶层的组件通信，那么绿色的组件需要层层把消息转发给父级组件，直到传到最顶层的组件，如果我们项目中的组件非常之多，组件之间又经常需要共享传值的话，那么使用react这种父子通信的方式，整个项目的开发就会变得非常冗余，也不易维护。&nbsp;前面说过，react是一个视图层框架（并不是什么问题都依靠react解决，react只解决数据和页面渲染——也就是搭建视图, 至于组件渲染交给别的数据层框架来做额外的支撑），所以我们需要一个数据层框架去协助react帮助数据管理，目前主流和react搭配的就是redux。&nbsp;redux要求我们把数据都存放在一个名为store的公共存储区域，我们把数据都存放在store中。如果想通过绿色的组件改变数据传给其他组件，那么我们只需要操作store就可以了，接着其他灰色的组件会自动感知到变化，然后重新去store中取数据，这样我们取到的数据，就是刚刚绿色组件所更改的数据。也就是说，redux间接地帮我们实现了组件通信的功能，让我们的组件通信变得非常的轻松。&nbsp; ❗️但是我们要知道，redux不是只为react服务的，而是为JavaScript服务的状态容器，react-redux才是专门为react服务的状态管理插件，本篇文章主要讲解redux。 redux 三大原则1.单一数据源store是唯一的。整个应用的数据被储存在一棵object tree(对象树)中，并且这个 object tree 只存在于唯一一个 store 中。&nbsp;2.state是只读的唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。&nbsp;3.使用纯函数执行修改为了描述 action 如何改变 state tree ，你需要编写 reducers。reducer必须是纯函数: 纯函数是指给定固定的输入, 就一定会有固定的输出, 且不会有任何副作用; 一旦一个函数有一个settimeout或者ajax或者new Date相关内容的时候, 它就不是一个纯函数, 所以reducer里不可以有异步的操作。❗️副作用: 例如对参数的修改就是副作用, 这个时候reducer也就不是一个纯函数了 Mutabilit(可变性) &amp; Immutability(不变性)在学习redux前，我希望你可以了解Mutabilit(可变性)和Immutability(不变性)这两个概念。&nbsp;首先从字面上理解，「可变」意味着可以出现变化，可以变化，就意味着可能会出现一些问题或是bug。&nbsp;「不可变」就代表某些数据是不可修变的，如果想要改变不可变的数据，那么只能去复制旧的数据，再产生新的数据来取代旧的数据，我们永远不要去修改旧的数据。&nbsp;我这里不做过多的赘述，如果你对这块有兴趣，可以去自行查找一些文章了解，本文只需要你了解这个概念。 redux的工作流程reactComponents： 每一个页面上的组件。actionCreators：管理action的地方。action：动作，它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store，通常是一个对象。store：存储数据的公共区域，也可以理解为把action和reducers联系到一起的对象。reducers：处理不同的action类型，告诉store该给组件什么样的数据，然后store再把这个数据给到对应的组件。&nbsp;这里你或许会看的有点蒙，我下面用代码来解释一下redux的工作流程。 安装redux npm安装 yarn安装 npm install —save redux yarn add redux redux代码讲解 我想实现一个todoList功能，当我点击提交按钮的时候，在input下面会增加我刚刚输入的内容。其中，input和button是父组件，下面的ul是子组件。效果如下 基础结构-取值先在刚刚搭建好的react项目中的src文件下建立一个store文件夹（你也可以建在任何的组件文件夹下），在store里分别创建一个index.js和reducer.js。&nbsp;reducer.js12345678910// 定义初始数据defaultState，如果不给state设置一个初始数据，那么最初state就是一个undefined。// 这里我已经为todoList写入了一个字符串inputValue和数组list。const defaultState = &#123; inputValue: '', list: ['默认数据1', '默认数据2']&#125;;export default (state = defaultState, action) =&gt; &#123; // state指的是上一次存储的数据, action是组件传过来的内容 return state;&#125; &nbsp;index.js123456789// 从redux引入createStore方法import &#123; createStore &#125; from 'redux'; // 从刚刚创建的reducer.js引入reducerimport reducer from './reducer';// 定义一个名为store的redux存储区，我们把reducer作为参数传入createStore方法来构造这个存储区，store里的数据只可以通过reducer来修改。const store = createStore(reducer);// 导出storeexport default store; &nbsp;创建子组件List.js1234567891011121314151617import React from 'react';const List = (props) =&gt; &#123; return ( &lt;div&gt; &lt;ul&gt; &#123; props.list.map((item, index) =&gt; &#123; return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; );&#125;export default List; ❗️此处的List组件是一个无状态组件，没有任何的逻辑操作，所有逻辑操作交由父组件执行。&nbsp;接着修改你的App.js (我这里把App.js作为父组件)1234567891011121314151617181920import React, &#123; Component &#125; from 'react'import store from './store'import List from './List'export default class App extends Component &#123; constructor(props) &#123; super(props); // 用store的getState()方法取出store的数据，再赋值给this.state this.state = store.getState(); &#125; render() &#123; return ( &lt;div&gt; &lt;input type="text"/&gt; &lt;button&gt;提交&lt;/button&gt; &lt;List list=&#123;this.state.list&#125;&gt;&lt;/List&gt; &lt;/div&gt; ) &#125;&#125; 此时运行出来应该是这样目录结构 修改store此刻我们已经可以取到store里的数据了，那么我们现在想在点击提交的时候，list里新增一条数据，并且实时地响应出来，应该怎么做呢。&nbsp;修改App.js1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; Component &#125; from 'react'import store from './store';import List from './List'export default class App extends Component &#123; constructor(props) &#123; super(props); this.state = store.getState(); // 修改事件的this指向，否则this指向undefined this.handleInputChange = this.handleInputChange.bind(this); this.handleClick = this.handleClick.bind(this); &#125; render() &#123; return ( &lt;div&gt; &lt;input type="text" onChange=&#123;this.handleInputChange&#125; value=&#123;this.state.inputValue&#125; /&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;提交&lt;/button&gt; &lt;List list=&#123;this.state.list&#125;&gt;&lt;/List&gt; &lt;/div&gt; ) &#125; handleInputChange(e) &#123; // 1) 创建action const action = &#123; type: 'change_input_value', value: e.target.value &#125; // 2) 传给store store.dispatch(action); // 3) store如果接收到了action, 会自动把之前的数据和action传给reducer (这步store帮我们做了) &#125; handleClick() &#123; const action = &#123; type: 'add_todo_item', &#125; store.dispatch(action); &#125;&#125; &nbsp;然后修改我们的reducer123456789101112131415161718192021const defaultState = &#123; inputValue: '', list: ['默认数据1', '默认数据2']&#125;;// 4) reducer拿到之前的数据和当前操作的信息后对数据进行处理，然后返回新的数据给storeexport default (state = defaultState, action) =&gt; &#123; const newState = JSON.parse(JSON.stringify(state)); //深拷贝，因为reducer可以接收state, 但绝不能修改state 所以要拷贝state switch (action.type) &#123; case 'change_input_value': newState.inputValue = action.value; return newState; //return给了store case 'add_todo_item': newState.list.push(newState.inputValue); // 添加成功后清空inputValue newState.inputValue = ''; return newState; default: break; &#125; return state;&#125; 此时我们会发现在input框里输入数据页面是没有反应的，点击提交，页面上也没有发生任何变化，别急，我们先来打印一下store，这也是我们学redux时经常容易犯的错误。&nbsp;我们在handleClick方法的最后，用store.getState()方法来打印一下store的值❗️注意是最后，store.dispatch(action)的后面1console.log(store.getState()); 我们发现store里的数据已经被改变了，list增加了1条数据，inputValue也被清空了，这证明我们之前在reducer中编写的代码都生效了，但是都并没有渲染在页面上。现在页面上input的value值是空值，是因为一开始inputValue的值就是空，而不是我们后来清空的。这一切都因为我们并没有在组件中去监听更新store里的数据，我们应该在页面中监听store，当store发生变化时，实时更新我们的数据。 监听storeApp.js最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React, &#123; Component &#125; from 'react'import store from './store';import List from './List'export default class App extends Component &#123; constructor(props) &#123; super(props); this.state = store.getState(); this.handleInputChange = this.handleInputChange.bind(this); this.handleClick = this.handleClick.bind(this); // 5) 监听store的变化 // 订阅store, 只要store发生改变, subscribe里的函数就会被自动执行 this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); &#125; render() &#123; return ( &lt;div&gt; &lt;input type="text" onChange=&#123;this.handleInputChange&#125; value=&#123;this.state.inputValue&#125; /&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;提交&lt;/button&gt; &lt;List list=&#123;this.state.list&#125;&gt;&lt;/List&gt; &lt;/div&gt; ) &#125; handleInputChange(e) &#123; const action = &#123; type: 'change_input_value', value: e.target.value &#125; store.dispatch(action); &#125; handleClick() &#123; const action = &#123; type: 'add_todo_item', &#125; store.dispatch(action); &#125; handleStoreChange() &#123; // 6) 当感知到store变化的时候, 调用store.getState()方法从store中重新取一次数据, 然后调用setState替换掉当前组件中的数据, 这样就会同步数据了 this.setState(store.getState()); &#125;&#125; ❗️我们上面说过，不要直接更改state的值，所以我们每次修改时都创建了一个新的state，返回的也是全新的state。不过，大量重复的代码就是问题的源泉，我们在编写代码时，理应去减少出现bug的可能性。所以，当我们日常开发时，我推荐使用immutable.js或一些其他的第三方库——我们在最初就把state生成immutable对象, 这样可以百分百保证state不会被改变。 总结拿刚刚的例子来说，我们首先把input的值和store中的inputValue关联到了一起，如果你想修改input框的value值，就必须通过修改store中的inputValue实现。我们用onChange事件监听了input，在每次修改input中的值的时候，我们都创建了一个action，并把这个action派发给了store。&nbsp;store接收到了这个action，会自动把这个action传给reducer。reducer拿到这个action，开始对比action的type值，并进行相应的数据操作，之后返回了一个新的数据给store。我们在组件内监听了store的变化，所以当reducer把值返回给了store，store更新了自己的数据，我们的组件就会监听到刚刚store的变化，随之更换组件内store的数据。&nbsp;input输入流程：App→store→reducer→store→App检测到store发生变化，更新数据，渲染页面&nbsp;点击提交流程：App→store→reducer→store→App.js检测到store发生变化，更新数据→父组件App重新渲染触发子组件List更新渲染&nbsp; 优化写到这里，如果你只想了解该怎么使用redux，那么至此之前的代码应该已经足够让你上手去使用redux了。但是其实上面的代码中还有很多可以优化的地方，我没有直接把优化过后的代码写出来是怕不易于初学者阅读学习，容易看晕。&nbsp;比如说我们应该利用actionTypes统一常量, 预防因拼写引发的bug，以及将action的创建放到actionCreators中统一进行管理。这样做的优点除了提高代码的可维护性，还可以方便自动化测试。&nbsp;在实际开发中，redux也应遵照组件化开发，建议每个组件都应该拥有自己的store文件夹，src目录下的store应仅仅作为各个组件内store的集合。&nbsp;在子组件List上，我们使用数组的index作为key值并不是一个好的做法。事实上我认为不到万不得已的情况不要使用index作为key值。因为列表每一项的顺序都可能会发生变化（比如说我们如果删除list中的某一项时，list的顺序就发生了变化，list中每一项的index值都发生了改变），react又是通过diff算法去渲染页面的，diff算法通过key值去对比虚拟dom，如果key值全部发生改变，那虚拟dom便会全部更新，这明显会降低我们的性能，所以说使用数组的index作为key值是下下策，有兴趣的话可以去看看这篇文章深度解析使用索引作为 key 的负面影响。&nbsp;因为diff算法（虚拟dom从顶层 层层比对）的原因，所以在父组件内只要一改变inputValue的值，子组件就会重新渲染，即使我们并没有修改list数据。这同样会降低我们的性能，试想一下，如果你拥有非常多的子组件，父组件输入任何一个字符都会导致所有子组件的重新渲染，这会消耗多少的性能呢？为了解决这种多余性能的消耗，我们应该在子组件内利用react内置的生命周期函数shouldComponentUpdate去阻止子组件跟随父组件去执行无谓的render函数，这样就可以避免虚拟dom的比对，提升性能。&nbsp; 这篇文章到这里就全部结束了，本来想在一篇里把redux和react-redux都写出来，但是怕太长了，所以下次找时间再写react-redux吧。&nbsp;如果你对这篇文章有任何疑问或补充，都可以在评论区给我留言讨论。&nbsp;顺便一提最近看了排球少年的动漫，虽然比较冷门但是真的是一部不可多得的好作品，无论你喜不喜欢排球我觉得你看了这部动漫后都会爱上它的，强烈安利一波。&nbsp;大家晚安啦。]]></content>
      <tags>
        <tag>categories</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常规操作【初始化/提交代码/撤销/删除/合并分支/储存变更】]]></title>
    <url>%2F2019%2F02%2F18%2FgitOrder%2F</url>
    <content type="text"><![CDATA[由于公司一直用的SVN对项目进行版本管理，所以一直也没怎么接触过git。虽然我之前有使用码云私有仓库管理代码，但是我对git的操作还停留在git add . git commit -m上。直到最近听说github的私有仓库免费了，所以我又抽时间看了下git的基本操作(免费使我进步，哈哈哈~~)，下面是我整理的笔记，希望对你有帮助。 基础部分初始化gitgit init 初始化 检查状态git status 检测文件状态(有没有被追踪Untracked) 提交到版本库的文件不会显示在git status里 GIT四种状态untracked 未被追踪modified 表示工作区修改了某个文件但是没有添加到暂存区staged 表示把工作区修改的文件添加到了暂存区但是没有比较到版本库Commited 表示数据被安全的存储在本地库中 GIT三层结构working directory 工作区staging index 暂存区git directory(Repository) 版本库 提交代码git add fileName 追踪 (从工作区添加到暂存区)git add . 追踪全部本地文件到暂存区git commit -m ‘描述’ 提交到版本库 告诉git使用者的身份git config —global user.name yourNamegit config —global user.email yourEmail 其他git config —list 查看git配置情况git log 查看提交信息(提交人/邮箱)git help 命令名 (例git help add):将弹出想要查找的命令的文档 撤销部分git add . + git commit -m ‘msg == git commit -am ‘msg’ 例如: git commit -m ‘versions 1.0’ 提交到版本库这时候不能使用 ‘versions 1.0’ 再次提交了 如果还想用这个名字的话 使用↓↓git commit—amend 撤销上一次的提交,并将暂存区的文件重新提交 也可以通过这个命令改变版本描述(不改变暂存区内容的情况下) git checkout — fileName 编辑器的文件恢复成了修改前的样子(最后一次提交)git checkout — . 撤销恢复全部文件 git reset HEAD fileName 撤销提交到暂存区 （这的HEAD为头指针）此处HEAD也可以换为版本号(将相应版本里的文件拉回到暂存区)这一步不会影响工作区↑↑,想工作区恢复 需要使用git checkout — fileNameUnstaged changes after reset(将改变撤销暂存); 可以通过git log 查看各种版本的版本号 然后通过版本号恢复到某个版本(这也会改变HEAD的指向)git reset 版本号(commit后面的) 文件名;再用git checkout — fileName 拉回来 删除部分git rm fileName:此步操作会把工作区的文件连同暂存区的文件一起被删除 当工作区的文件或者暂存区的文件被修改后,想进行git rm 操作,git会禁止我们删除,起到了一个防止误删除的作用。如果想要保留工作区的文件 那么就要用git rm —cached 文件名 来仅仅删除暂存区的文件git rm — cached fileName 在不小心将不需要追踪的文件添加到暂存区后,想删除暂存区的文件但是不想删除工作区的文件很有用git rm -f fileName 同时删除工作区和暂存区的文件mv fileName newFileName 本地(工作区)重命名mv fileName newFileName 工作区和暂存区都重命名 git指针概念Git指针当提交一个版本的时候,就会有一个版本号(V1),这时候有两个指针指向这个版本,一个是master(当前分支指针),一个是HEAD(指向当前分支的最后一个版本)当提交了一个新的版本(V2),master指针和HEAD指针都指向了最新一次的提交(V2),V2有一个指针指向V1。这的指针是指（文件中有一块地方保存着其他文件的地址），调用V2的时候可以直接通过V2找到V1的地址，从而调用V1，以达到方便的访问V1的目的，以此类推。如果在V2版本上创建了一个分支（D1）的时候，master分支指针依旧会指向V2，新的D1分支指针会指向新的D1分支,当切换到D1分支的时候,head指针会切换到D1上,此时的D1还有一个指针指向V2。修改D1分支的时候,D1和head指针也会以此类推到D2。当从D2合并分支到V2的时候，会形成V3分支，V3分支既指向V2分支，又指向D2分支。此时HEAD和master指针指向V3分支。 分支部分git branch 查看本地分支git branch -a 查看远程分支git branch branchName 创建新分支git checkout branchName 切换分支git branch -d branchName 删除分支 (此操作必须保证当前的分支非想要删除的那个分支)git branch -m branchName newBranchName 修改分支名git checkout -b branchName 创建分支并切换分支 合并分支首先切换到主分支（master）git merge branchName 合并分支这时候如果branch和master在相同位置有不同的修改,也就是发现了冲突的时候,git会抛出一个让我们来手动解决冲突的错误↓↓。automatic merge failed:fix conflicts and then commit result.(自动合并失败:修复冲突，然后提交结果。)&lt;&lt;&gt;&gt;branchName 是branchName分支的内容然后重新git commit -am ‘msg’ 提交到暂存区及版本库; git diff 比较差异(默认比较工作区和暂存区文件的差异) 如果没有差异是不会有任何展示的git diff —staged 比较暂存区与版本库之间的差异git diff 还可以比较同一个分支中两个不同的版本之间的差异(在版本回退时非常有用)版本hash值 最少选择4个 git默认选择7个 建议尽量选择8-10个 这样才能保证唯一性git diff branchName 还可以比较两个分支之间的差异 储存变更部分比如在branch分支上进行修改后,切换到master分支,会报一个please commit your changes or stash them before you switch branches;(请在切换分支之前提交更改或将其隐藏)的错误,我们使用git stash 暂存工作区的修改,然后git会帮我们自动切换到修改前的状态这时切换分支就不会报错了,因为git在进行分支切换的时候,主要改变的是版本库,当工作区有改变的时候,会直接将工作区的改变覆盖到另外一个分支上,从而影响另外一个分支。如果我们使用git stash进行封存,git就会自动将工作区的改变撤销掉,回到修改前的状态(上一次提交后的状态)。git stash list 查看当前保存了哪些本地文件git stash apply stash@{0} 返回之前用git stash封存的改变stash@{0} 里面的0根据提交git stash的次数以此类推git stash pop stash@{0} 拉回到暂存区和本地此时再执行 git stash list 查看封存的文件时 stash@{0}不见了也就是说 git stash pop stash@{0} 是在git stash apply stash@{0}的基础上,增加了一个删除命令。也就是说，返回的同时，删除git stash中的这个文件的命令。git stash drop stash@{0} 删除封存的修改。综上 git stash pop stash@{0} = git stash apply stash@{0} + git stash drop stash@{0} 使用远程仓库管理代码(github/码云)git push 远程仓库地址 (分支:可不填) :推送到远程仓库git pull如果使用ssh地址在管理员账户使用 ssh-keygen 生成密钥 文档后缀为File的为私钥 后缀为PUB(public的缩写) File为公钥然后点击github→setting→SSH→New SSH key→输入标题/添加公钥;此时就可以用SSH地址拉取了 推代码到远程仓库:方法1: git push git@github.com:仓库名称(name/xxx.com.git); 方法2: git push 仓库地址(https://github.com/name/xxx.com.git) 方法2: git remote add 取一个仓库名(通常使用origin) git@github.com:仓库名称(name/xxx.com.git); git remote -v 查看添加的远程仓库然后使用 git push origin master 推送到远程仓库 git pull 仓库名 分支名(master) 拉取到本地 让git不追踪指定文件如果有一些文件不想让git对它追踪touch .gitignore : 在项目目录下建立一个 .gitignore文件vim .gitignore 编辑这个文件然后把想忽略的文件添加到cmd命令行或者可以 index.* :忽略所有以index.为开头的文件(支持glob规则)也可以在里面加上.gitignore 让他忽略.gitignore文件glob规则: (&#42;号)匹配零或多个任意字符 [abc]匹配任何一个列在方括号中的字符 (?号)只匹配一个任意字符 [0-9]/[a-z]匹配范围 已经长传到暂存区/版本库的想忽略的文件,可以:git rm index.html —cached 删除暂存区的文件任何再提交 git commit -m ‘msg 提交↑的操作:这时,提交的还是暂存区的文件,本地仍然是改变这个index.html,这个改变并没有提交到暂存区,更没有到版本库只有将暂存区里相应文件删除后,忽略才生效 ~]]></content>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「N1语法」かたがた、かたわら、がてら的区别]]></title>
    <url>%2F2018%2F12%2F28%2FN1-ktwr-ktgt-gtr%2F</url>
    <content type="text"><![CDATA[前言从今天开始，我会陆续整理N1与N2易混淆的语法，以便日常复习记忆。说到易混淆的语法，我第一个想到的就是N1语法的「かたがた、かたわら、がてら」这三大壮汉。不夸张的说，有些已经通过N1的小伙伴可能都不太能分清这三者，好了，废话不多说，先来看一下它们三者的接续方法。 接续方法 かたがた かたわら がてら 名词（サ变词干） 名词+の 名词（サ变词干） 动词原形 动词ます形 用法及造句1、A かたがた B日文解释：AのついでにBをする。AをかねてBをする。 1、书面用语2、趁着做A的机会顺便做B，多用于信件和正式场合。例：「お礼を言う、お見舞い、ご報告、ご挨拶」等。造句：先日のお礼かたがた、お見舞いに行く。 2、A かたわら B日文解释：Aと同時に/の合間にbをする。 1、一边做A的同时，顺便做B，A为本质。2、必须是长期的事。造句：彼は勉強のかたわら、アルバイトをしている。 3、A がてら B日文解释：Aしながら/のついでにBをする。 1、与かたがた相似，较口语2、趁着做A顺便做B（A、B有主次顺序，是短期的事）。造句：夕涼みがてら、蛍を見に行った。 日本人眼中的语法说起来挺有趣的，之前碰巧给一个日本的朋友看过这三个语法，他却和我说从来没看到过かたがた这个用法，甚至连它的意思都不是很清楚。 从聊天截图可以看出，日常中他们连かたわら和がてら也不怎么用，所以到底要在什么时候使用这三个语法，还是根据实际情况自己考量吧。 以上です。]]></content>
      <tags>
        <tag>notes</tag>
        <tag>N1</tag>
        <tag>日语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈深拷贝、浅拷贝的区别【Vuex踩坑记录】]]></title>
    <url>%2F2018%2F12%2F24%2FdepthClone%2F</url>
    <content type="text"><![CDATA[vuex踩坑记录前一阵子在使用Vuex的时候，有这样一个报错。 Do not mutate vuex store state outside mutation handlers. 直译过来就是不要在突变处理程序之外改变vuex存储状态。 我们都知道，既然使用了vuex，那么想要更改vuex中store的状态的唯一方法就是提交mutation，因为vuex不允许直接修改store的内容，所以才会报这个错误。我在已知这点的情况下，先slice()了vuex里的数据，再进行使用，可还是报了相同的错误。后来查了下资料，才发现是深浅拷贝的问题，下面就来浅谈一下深浅拷贝的区别，以及总结几种不同的深浅拷贝方法。 深浅拷贝介绍在很多编程语言中（例如Java、JavaScript、C++），不同的数据类型，对应着不同的内存存储方式，基本数据类型通常保存在栈内存中，而引用类型仅仅是在栈内存中保存了一个指向堆内存的地址，通过在栈内存中保存的地址，去访问到保存在堆内存中的值。我们所说的浅拷贝，正是拷贝了栈内存中的引用类型数据的指针，而深拷贝，则是在拷贝数据内容的同时，生成新的指针，在堆内存中开辟自己的空间。我用大白话来解释一下，所谓的浅拷贝，比方说我们有b这样一个对象，我们用a复制了b，当我们改变b的时候观察a会不会随之变化，如果a也变了，那就是浅拷贝（因为只复制了栈内存中的指针，它们指向的还是相同的堆内存空间），如果a没变，那证明a和b在堆内存中分别占用了不同的空间，也就是深拷贝了。 浅拷贝1234//我在此处定义了一个变量aVuexData，aVuexData是一个包含三个对象的数组。let aVuexData=[&#123;name:'Jack',age:18&#125;,&#123;name:'Tom',age:20&#125;,&#123;name:'David',age:15&#125;];let arr=aVuexData;console.log(arr==aVuexData);//true,证明arr与aVuexData的指针相同，它们指向堆内存中相同的数据。 紧接着我们修改arr。12arr[0].name='Hank';console.log(aVuexData[0].name=='Hank');//true aVuexData[0].name==’Hank’为true，证明aVuexData[0]的name值由原先的Jack变成了Hank，但我们没有对aVuexData做任何操作，aVuexData是随着arr改变而改变了，这是显而易见的浅拷贝。 slice()拷贝我们知道slice()方法可从已有的数组中返回选定的元素，它的返回值是一个新的数组。这样看来，slice()似乎可以帮我们达到深拷贝的目的，但它并不可靠，这也正是我在vuex里报错的原因，下面来看一个例子。接着使用上面的aVuexData。123let arrNew=aVuexData.slice();console.log(arrNew==aVuexData);//false，也就是说，此处的arrNew与aVuexData指向了不同的指针地址，即使数据相同，它们也各自在堆内存中拥有着自己的一席之地。console.log(arrNew[0]==aVuexData[0]);//true 注意，这时候打印arrNew[0]与aVuexData[0]是否相等，返回的结果是true，证明它们的指针还是指向同一个堆内存地址，也就是说，我们虽然深拷贝了外层的数组，但并没有对数组中的引用类型数据进行深拷贝——它依旧是仅仅拷贝了指针地址，依旧是一个浅拷贝。slice()并没有让内层的引用类型数据开辟新的堆内存空间，这也正是vuex报错的原因，我们在改变内层数据的时候，其实还是直接修改了在vuex的store里的数据，所以才会报错。 concat()拷贝1let arrNew = [].concat(aVuexData); concat()方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。在拷贝引用类型的数据时，concat()方法的效果与slice()方法完全相同。slice()与concat()都可以进行引用类型内数据为基本类型数据的深拷贝，但我认为这样做太过冒险，因为一旦内容里被加上了一个引用类型的值，那么它就不再是一个深拷贝了，所以为了以防万一，我还是把这两个方法归在了浅拷贝里。 深拷贝那么，究竟怎样才能万无一失的进行深拷贝呢？ 递归方法我这边自己封装了一个函数1234567891011121314151617181920212223242526let DeepClone = (value) =&gt; &#123; let type = typeof value; //因为数组要用到push 对象要用Object.keys 所以得是不用的类型 这里先定义undefined 在后面定义类型 let newone = undefined; if (type === 'string' || type === 'number' || type === 'boolean') &#123; //基础类型 newone = value; //基础类型直接等于就好了 &#125; else if (type === 'object') &#123; //堆类型 if (value === null) &#123; newone = null; &#125; else if (Object.prototype.toString.call(value).slice(8, -1) === 'Object') &#123; //对象要先将newone改为对象类型 newone = &#123;&#125;; for (let key of Object.keys(value)) &#123; newone[key] = DeepClone(value[key]); //递归直到值为基本类型 &#125; &#125; else if (Object.prototype.toString.call(value).slice(8, -1) === 'Array') &#123; newone = []; //对象要先将newone改为数组类型 for (let i = 0; i &lt; value.length; i++) &#123; newone.push(DeepClone(value[i])) //与对象同理 &#125; //不用foreach是如果有undefined会有bug &#125; &#125; return newone &#125; //测试 let arrDeepClone = DeepClone(aVuexData); console.log(arrDeepClone[0]==aVuexData[0]);//false 此时，它们的内层数据也已经开辟了新的堆内存空间，是一个完完全全的深拷贝了。 利用JSON对象的stringify和parseJSON.stringify()方法用于将 JavaScript 值转换为 JSON 字符串。JSON.parse()方法用于将一个 JSON 字符串转换为对象。1234567let jsonDeepClone = (value) =&gt; &#123; let obj = JSON.stringify(value), objClone = JSON.parse(obj); return objClone;&#125;let arrJsonDeepClone = jsonDeepClone(aVuexData);console.log(arrJsonDeepClone[0] == aVuexData[0]); //false，同样实现了深拷贝 所有的打印结果一览 闲聊终于赶在圣诞节前把这篇文章整理出来了，非常的开心 ~ 因为最近刚刚把博客搭出来，还处在一个总结整理的阶段，所以每写一篇新的文章，感觉都是对过去自己的肯定，也希望我过去这一段时间的踩坑经验可以帮助到更多人解决工作与学习上的问题。如果你觉得我的文章对你有帮助，请点个赞鼓励一下我，这样我会加大马力继续努力多出些干货的，嘻嘻。如果你对本文有任何的疑问或补充，都欢迎在评论区给我留言讨论，最后祝大家平安夜、圣诞节快乐，记得吃苹果哦 ~🍎🍎感谢观看。]]></content>
      <tags>
        <tag>categories</tag>
        <tag>vue</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用网易云生成你自己的音乐外链、提取lrc歌词文件、专辑图片。]]></title>
    <url>%2F2018%2F12%2F12%2FmusicLinks%2F</url>
    <content type="text"><![CDATA[&nbsp;在使用各种HTML5音乐播放器的时候，我们通常需要借助一些音乐网站寻找音乐外链，或者是自己用云服务器生成音乐外链，但是音乐外链网站的歌曲数量实在有限，自己生成又浪费时间成本。前一阵子我在搭建博客的时候，使用的是aplayer播放器，顺便自己研究了下怎么用网易云生成音乐外链，非常实用且便捷快速。本篇文章就来总结一下如何使用网易云音乐网站生成你自己的音乐外链、提取专辑图片以及lrc歌词文件。有关于aplayer的使用，我在之后会单独写一篇文章来讲。我在写这篇文章的时候，避免使用了一些专有词汇，无论你会不会使用开发者工具，都可以轻便的上手，当然开发大佬请无视。 提取音乐外链首先，打开网易云音乐的官网，搜索你想要的音乐。 踩坑记录在说正确提取外链方式之前，我先来介绍一下我当时踩的坑，真是一把血泪，如果对这部分没兴趣的朋友可以直接跳到生成外链部分。当时我获取音乐外链的方式是在音乐界面点击左侧的“生成外链播放器”，如下图所示。然后在点开的页面里单击鼠标右键打开检查，然后在最上面一栏寻找Network，找到它下面的Media（如果是空的则重新刷新页面），右键点击下面的Copy，选择Copy link address，这样我就得到了这首歌的音乐外链，不过，在后续使用过程中我发现，这样获取的音乐外链会在一段时间后失效，导致我网页的歌时好时坏，最初我还怀疑自己复制错了值，在我重复测试几次之后，证明这样获取的外链确实会不定期刷新。所以即便这种方式方便快捷，可它却并不可靠。当时使用的方法如下↓。不过好在，我之后找到了更简易的办法，就是直接复制网站的网址。 生成外链首先，我们先来复制一下歌曲的网址。然后，重点来了！ 音乐网址：https://music.163.com/#/song?id=557583012 修改后的网址：https://music.163.com/song/media/outer/url?id=557583012.mp3 修改后的网址也就是你所需要的音乐外链，过程就是删除前面的#号，在song后面加上/media/outer/url，最后在结尾处加上.mp3就大功告成啦，没错，就是这么简单，你就拥有了不需要任何云服务器的音乐外链。顺便在这里强推一下断眉的这首Patient，实在是太好听了！PS:这样做可以把网易云不允许你生成音乐外链的版权音乐的音乐外链生成出来，不过我并不推荐你这么做，因为我觉得版权意识还是需要靠大家一起普及开来，所以希望大家在做音乐外链的时候尽量选用那些可以生成外链的音乐。例如上面这首Patient就是一首版权音乐，我在这里只是演示一下生产外链的方法，虽然我很想把这首歌放到博客里给你们听，但是为了版权，还是建议大家自己去网易云音乐听吧 ~ 提取lrc歌词文件首先，还是在网易云音乐的官网搜索你想要的音乐，然后点开Network，此时注意下面一行的选项必须在All上，如果刚刚选择了Media要记得切换回来，然后在搜索框输入lyric（如果没有展示F5刷新页面），把显示出的那个文件右键copy→copy response，如下图。下一步从最上方的Network切换到Console。 然后输入a=在此处粘贴你刚刚复制的内容，并回车，展示如下图。 紧接着输入a.lrc.lyric，回车，下面就是你要提取的lrc歌词文件啦。 如果输入a.tlyric.lyric，那么就是歌词的翻译版本。 提取专辑图片还是点开Network，选取下面一行的img，Copy➡️Copy link address获取图片外链，或者你也可以双击图片，使浏览器在新的网页中展示这张图片，此时我们就可以右键保存它，位置如下↓。 到此，你已经拥有了lrc歌词文件、专辑封面、以及最重要的音乐外链，你可以随意去生成你喜欢的歌单了，如果对以上的内容有任何疑问或补充，欢迎在评论区留言给我。感谢观看。鞠躬 ~]]></content>
      <tags>
        <tag>categories</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue+vue-i18n搭建国际化网站【兼容Element-UI、动态切换css】]]></title>
    <url>%2F2018%2F12%2F08%2FvueI18n%2F</url>
    <content type="text"><![CDATA[&nbsp;最近因为雾霾很厉害，所以发烧了在家养病，想着难得有空，正好趁机整理一下以前在项目中遇到过的问题及需求。今天想来写一下之前为项目搭建的国际化（i18n）功能，由于之前项目主要是使用的Vue+Element-UI，所以本文章中分别有vue-i18n和兼容element-ui的vue-i18n两种写法，大家可以按需参考。 前言本文是基于vue进行实现的国际化功能，我假设你对vue已经有了一定的了解，并且已经拥有了属于你自己的vue项目环境，这里不做过多阐述，如果对这一步有疑问的话，请参考我的另一篇文章，进行项目搭建。如果你只是急需一个已经搭建好的i18n模版，也可以直接去我的github仓库下载我已经写好的项目模版。 vue-i18n安装vue-i18n1npm install vue-i18n 配置文件如下图创建i18n文件夹，在i18n文件夹里分别创建i18n.js、langs文件夹，在langs文件夹下面创建你的语言文件（cn.js/en.js/ja.js）和index.js文件。语言包分别为中文/英文/日语，大家在项目中选择创建自己需要的语言包即可。 i18n.js1234567891011import Vue from 'vue'import VueI18n from 'vue-i18n'import messages from './langs'Vue.use(VueI18n)//从localStorage中拿到用户的语言选择，如果没有，那默认中文。const i18n = new VueI18n(&#123; locale: localStorage.lang || 'cn', messages,&#125;)export default i18n index.js12345678import en from './en'import cn from './cn'import ja from './ja'export default &#123; en, cn, ja,&#125; cn.js1234567const cn = &#123; message: &#123; 'hello': '你好', &#125;&#125;export default cn en.js1234567const en = &#123; message: &#123; 'hello': 'hello', &#125;&#125;export default en ja.js1234567const ja = &#123; message: &#123; 'hello': 'こんにちは', &#125;&#125;export default ja 🌟 在配置语言包的时候，key值一定要保持统一，因为i18n是通过你的key值来切换语言的，如果key值有误，就不能正确的切换语言包，这一点千万要注意。 main.js123456789import i18n from './i18n/i18n'new Vue(&#123; el: '#app', router, i18n, //加上i18n components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 到此我们的i18n已经全部配置结束了，下面我们去页面中进行使用。 配置页面HTML部分1234&lt;p&gt;&#123;&#123;$t(‘message.hello’)&#125;&#125;&lt;/p&gt;//此时应该是中文&lt;button @click="switchLang('en')"&gt;英语&lt;/button&gt;&lt;button @click="switchLang('cn')"&gt;中文&lt;/button&gt;&lt;button @click="switchLang('ja')"&gt;日语&lt;/button&gt; Js部分1234567methods:&#123; switchLang(lang) &#123; this.$i18n.locale = lang //把语言保存在localStorage中 localStorage.setItem('lang',lang); &#125; &#125;, 到此，运行npm run dev就可以看到可以进行语言切换的项目了。 根据语言切换css到此，我们已经实现了基本的国际化功能。但是，我们在切换语言的时候不得不面临的一个问题就是因为语言的不同，即使是同一句话，文字样式的长度也会不同。所以这时候特别容易产生一些页面样式上的结构错位，为此我们就需要根据不同语言来切换项目的css。我这边提供的思路是在最上层html的div上添加一个可以动态切换class的变量，以改变项目的父级的class名称，实现切换语言的同时切换css样式。 HTML部分1234&lt;template&gt; &lt;div :class="langCss"&gt; &lt;/div&gt;&lt;/template&gt; Js部分在data中定义保存class的变量123456data () &#123; return &#123; langCss:window.localStorage.getItem('lang')||'cn', //先去取localStorage里保存的语言，如果没有，那么就默认中文 //这么做的意义是为了用户在刷新页面的时候样式不丢失。 &#125; 紧接着在我们的switchlLang函数后添加新的一行，以便在切换语言的同时切换class。12345switchLang(lang) &#123; this.$i18n.locale = lang localStorage.setItem('lang',lang); this.langCss=lang;//新添加的，以便切换父级class &#125; Css部分在style标签中中设置你想要的样式，我这边以改变文字颜色为例。123456789.en button &#123; color: steelblue;&#125;.cn button &#123; color: #666;&#125;.ja button &#123; color: seagreen;&#125; 到此vue-i18n的内容就全部结束了，由于现在很多人在使用vue的同时会搭配Element-UI使用，所以我们在现在的基础上优化一下我们的项目，以便可以兼容Element-UI。 兼容Element-UI的i18n参考网址Element组件文档Element官网-i18n 安装Element相关依赖npm i element-ui -s 修改配置main.js123456789101112//引入element-uiimport ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';Vue.use(ElementUI);new Vue(&#123; store:store, i18n, ElementUI,//添加element-ui el: '#app', components: &#123; App &#125;, template: '&lt;App/&gt;',&#125;) i18n.js1234567891011121314import Vue from 'vue';import locale from 'element-ui/lib/locale';import VueI18n from 'vue-i18n';import messages from './langs';Vue.use(VueI18n);//从localStorage中拿到用户的语言选择，如果没有，那默认中文。const i18n = new VueI18n(&#123; locale: localStorage.lang || 'cn', messages,&#125;)locale.i18n((key, value) =&gt; i18n.t(key, value)) //为了实现element插件的多语言切换export default i18n 修改语言包123456789101112131415161718192021222324252627282930313233343536// en.jsimport enLocale from 'element-ui/lib/locale/lang/en'const en = &#123; message: &#123; 'hello': 'hello', &#125;, ...enLocale&#125;export default en;// **********分割线**********// cn.jsimport zhLocale from 'element-ui/lib/locale/lang/zh-CN'const cn = &#123; message: &#123; hello: '你好，世界', &#125;, ...zhLocale&#125;export default cn;// **********分割线**********// ja.jsimport jaLocale from 'element-ui/lib/locale/lang/ja'const ja = &#123; message: &#123; hello: 'こんにちは、世界', &#125;, ...jaLocale&#125;export default ja; 如果console里有如⬇️警告，证明的你语言包没有配置正确，返回上一步修改语言包查看。 配置页面引用组件至此，我们就可以引入一个Element-UI的组件进行开发了，这里以dialog组件为例演示一下基于Element-UI的文字国际化方案。当然，你也可以去Element组件文档去引用一些别的组件，这全看你自己的项目需要。 我引用的是第一个dialog组件【基本用法】，引用成功后，页面如下图，这里不对组件引用做过多阐述。此时切换语言后，我们发现暴露在外层我们可修改的语言文字并不会有变化，但是你点击右上角的关闭符号后，会发现里面内置的语言已经改变了。 Js调用下面需要我们来手动配置一下未切换文字的语言包，配置方法同上文的配置页面，这里我顺便说一下，在js里调用国际化直接用this.$t(‘message.xxx’)即可，如下。1234567handleClose(done) &#123; this.$confirm(this.$t('message.confirm'))//js内部切换 .then(_ =&gt; &#123; done(); &#125;) .catch(_ =&gt; &#123;&#125;); &#125; github地址到此，国际化内容全部结束，我把所有代码都放到了我的github仓库上，里面提供了vue-i18n以及兼容Element-UI的两种国际化版本。假如上文中还有哪里不明白的，可以直接下载下来参考。如果有任何疑问或补充，欢迎在评论区给我留言讨论。感谢观看鞠躬 ～]]></content>
      <tags>
        <tag>categories</tag>
        <tag>vue</tag>
        <tag>i18n</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vue-cli从0搭建Vue开发环境]]></title>
    <url>%2F2018%2F12%2F08%2FBuildProjectsVue%2F</url>
    <content type="text"><![CDATA[&nbsp;在程序开发中，有三种方式可以创建vue项目，分别是本地引用、使用CDN引入vue.js、使用vue-cli搭建项目。本文主要介绍使用vue-cli搭建项目。 准备工作安装node请确保你的电脑上安装了node.js，以便于用npm包管理安装环境。如果还没有安装，请去node官网下载安装。 如果安装完成,打开你的终端（Windows-&gt;运行-&gt;cmd、macOS-&gt;command+space-&gt;输入“终端”），使用1node -v 检查你的node版本，出现版本号为已安装，如下图。 全局安装vue-cli1npm install -g vue-cli 如果报错证明你没有安装的权限，执行1sudo npm install -g vue-cli 然后输入你的管理员密码，安装成功。 搭建项目1vue init webpack project-name（你的项目名） 配置说明123456789Project name 项目名称Project description 项目描述Author 作者Vue build 打包方式（可直接回车）Install vue-router? 是否需要安装router，选y（一般项目中肯定会用到）。Use ESLint to lint your code? 是否需要js语法检测（可直接回车）Set up unit tests 是否安装单元测试工具（可直接回车）Setup e2e tests with Nightwatch? 是否需要端到端测试工具（可直接回车）Should we run `npm install` for you after the project has been created? 是否在项目执行完成后为您运行npm install（安装依赖，选y，当然你也可以后续自己手动安装依赖⬇️） 手动安装依赖12cd 你的vue项目npm run install 运行项目1npm run dev 出现️⬇️表示已运行成功，可以通过http://localhost:8080查看你的项目了。12DONE Compiled successfully in 2511ms 01:20:53I Your application is running here: http://localhost:8080 示例效果]]></content>
      <tags>
        <tag>categories</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客测试]]></title>
    <url>%2F2018%2F11%2F07%2FMy-New-Post.1%2F</url>
    <content type="text"><![CDATA[请输入密码阅读本博客。 Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建记录]]></title>
    <url>%2F2018%2F11%2F07%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[请输入密码阅读本博客。 Incorrect Password! No content to display! U2FsdGVkX1+38VyzRQ5vETBqloo/5nxoiYiQU/vHcjNd2Tbn6m0IEbuuAAqsBsf7FoRaEw+XNpFGCoo1ghwOjKpTp34XZBh27gr2KNae9/uvlOFNk/F3G825ewxEAK3rm0xG7XVt6gnsntt+USME2FcXAv5l2eUvm3UKScAeZeMRTVW/BTxdHSbL/Hf4yAMNrMXuTR2FrfQU2alKi8tDoi9g0kVLZlWzQc/hMoFfIZNgJbrZa0BlE8BZ4ovb1yT0yo9Mw9npXawe62o9y0FDjrIDpEB/PE98A8wp/eBYnBhvdH9riWHTV4n/LHWxHTaQtoxCqCumsMgrlPF3rdZFQ5wnokTEk0Dl9b6ahm4T51JunHGyUDFO+XlPFaIt9b47AoO6JoCegpsTrlZoW3+GTpD+eztUKNWAoFwE3q9PbcQ=]]></content>
      <tags>
        <tag>categories</tag>
      </tags>
  </entry>
</search>
